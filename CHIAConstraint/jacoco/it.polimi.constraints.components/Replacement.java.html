<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Replacement.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CHIAConstraint</a> &gt; <a href="index.source.html" class="el_package">it.polimi.constraints.components</a> &gt; <span class="el_source">Replacement.java</span></div><h1>Replacement.java</h1><pre class="source lang-java linenums">package it.polimi.constraints.components;

import it.polimi.automata.IBA;
import it.polimi.automata.state.State;
import it.polimi.constraints.transitions.PluggingTransition;

import java.util.AbstractMap;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Set;

import org.apache.commons.lang3.tuple.ImmutableTriple;
import org.apache.commons.lang3.tuple.Triple;

import rwth.i2.ltl2ba4j.model.IGraphProposition;

import com.google.common.base.Preconditions;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;

/**
 * The Replacement class extends the Component class and specifies the IBA which
 * represent the model that describes the replacement of the black box state.
 * 
 * @author Claudio Menghi
 *
 */
public class Replacement extends Component {

	/**
	 * contains the IBA corresponding to the sub-property
	 */
	private final IBA automaton;

	/**
	 * contains the incoming ports of the component
	 */
	private final Set&lt;PluggingTransition&gt; incomingTransitions;

	/**
	 * contains the out-coming ports of the component
	 */
	private final Set&lt;PluggingTransition&gt; outgoingTransitions;

	/**
	 * maps a state of the model to the corresponding outgoingTransitions
	 */
	private final Multimap&lt;Triple&lt;State, State, Set&lt;IGraphProposition&gt;&gt;, PluggingTransition&gt; mapOutgoingTransitions;

	/**
	 * 
	 */
	private final Multimap&lt;Entry&lt;State, Set&lt;IGraphProposition&gt;&gt;, PluggingTransition&gt; mapIncomingTransitions;

	/**
	 * creates a new sub-property that refers to a specific model state and
	 * contains the corresponding IBA
	 * 
	 * @param modelState
	 *            is the state of the model to which the sub-property
	 *            corresponds with
	 * @param automaton
	 *            is the automaton related with the sub-property
	 * @param incomingTransitions
	 *            the incoming transitions of the replacement
	 * @param outcomingTransitions
	 *            the outgoing transitions of the replacement
	 * 
	 * @throws NullPointerException
	 *             is generated when the name of the state or when the state of
	 *             the model is null
	 */
	public Replacement(State modelState, IBA automaton,
			Set&lt;PluggingTransition&gt; incomingTransitions,
			Set&lt;PluggingTransition&gt; outcomingTransitions) {
<span class="fc" id="L78">		super(modelState);</span>
<span class="fc" id="L79">		Preconditions.checkNotNull(automaton,</span>
				&quot;The name of the state cannot be null&quot;);
<span class="fc" id="L81">		Preconditions.checkNotNull(incomingTransitions,</span>
				&quot;The set of the incoming ports cannot be null&quot;);
<span class="fc" id="L83">		Preconditions.checkNotNull(outcomingTransitions,</span>
				&quot;The set of the outcoming ports cannot be null&quot;);

<span class="fc" id="L86">		this.incomingTransitions = new HashSet&lt;PluggingTransition&gt;();</span>
<span class="fc" id="L87">		this.outgoingTransitions = new HashSet&lt;PluggingTransition&gt;();</span>
<span class="fc" id="L88">		this.mapOutgoingTransitions = HashMultimap.create();</span>
<span class="fc" id="L89">		this.mapIncomingTransitions = HashMultimap.create();</span>
<span class="fc" id="L90">		this.automaton = automaton;</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">		for (PluggingTransition incomingTransition : incomingTransitions) {</span>
<span class="fc" id="L92">			this.addIncomingTransition(incomingTransition);</span>
<span class="fc" id="L93">		}</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">		for (PluggingTransition outgoingTransition : outcomingTransitions) {</span>
<span class="fc" id="L95">			this.addOutgoingTransition(outgoingTransition);</span>
<span class="fc" id="L96">		}</span>

<span class="fc" id="L98">	}</span>

	/**
	 * returns the IBA associated with the replacement
	 * 
	 * @return the IBA associated with the replacement
	 */
	public IBA getAutomaton() {
<span class="fc" id="L106">		return this.automaton;</span>
	}

	/**
	 * adds an outgoing transition to the component
	 * 
	 * @param transition
	 *            is the transition to be added as an outgoing transition
	 * @throws NullPointerException
	 *             if the transition is null
	 * @throws IllegalArgumentException
	 *             if the source of the transition is not a state of the
	 *             automaton associated with the replacement
	 */
	public void addOutgoingTransition(PluggingTransition transition) {

<span class="fc" id="L122">		Preconditions.checkNotNull(transition,</span>
				&quot;The port to be added cannot be null&quot;);
<span class="fc" id="L124">		Preconditions</span>
<span class="fc" id="L125">				.checkArgument(</span>
<span class="fc" id="L126">						this.automaton.getStates().contains(</span>
<span class="fc" id="L127">								transition.getSource()),</span>
						&quot;The source &quot;
<span class="fc" id="L129">								+ transition.getSource()</span>
								+ &quot; of the outgoing transition must be a state of the replacement automaton&quot;);
<span class="fc" id="L131">		this.outgoingTransitions.add(transition);</span>
<span class="fc" id="L132">		this.mapOutgoingTransitions.put(</span>
				new ImmutableTriple&lt;State, State, Set&lt;IGraphProposition&gt;&gt;(
<span class="fc" id="L134">						transition.getSource(), transition.getDestination(),</span>
<span class="fc" id="L135">						transition.getTransition().getPropositions()),</span>
				transition);
<span class="fc" id="L137">	}</span>

	/**
	 * return the set of the outgoing transitions of the replacement
	 * 
	 * @return the outgoing transitions of the replacement
	 */
	public Set&lt;PluggingTransition&gt; getOutgoingTransitions() {
<span class="fc" id="L145">		return Collections.unmodifiableSet(outgoingTransitions);</span>
	}

	/**
	 * returns the collection of outgoing transitions which have as source the
	 * model state. If no outgoing transitions are associated with the model
	 * state an empty collection is returned
	 * 
	 * @param modelState
	 *            the state of the replacement from which the outgoing
	 *            transitions are fired
	 * @param destinationState
	 *            the destination of the outgoing transitions to be returned
	 * @param propositions
	 *            the propositions that label the outgoing transitions
	 * @return the collection of the outgoing transitions which have the
	 *         modelState as source state
	 * @throws NullPointerException
	 *             if the model state is null
	 * @throws IllegalArgumentException
	 *             if the model state is not a state of the replacement
	 *             automaton
	 */
	public Collection&lt;PluggingTransition&gt; getOutgoingTransitions(
			State modelState, State destinationState,
			Set&lt;IGraphProposition&gt; propositions) {
<span class="fc" id="L171">		Preconditions.checkNotNull(modelState, &quot;The modelState cannot be null&quot;);</span>
<span class="fc" id="L172">		Preconditions</span>
<span class="fc" id="L173">				.checkArgument(</span>
<span class="fc" id="L174">						this.automaton.getStates().contains(modelState),</span>
						&quot;The modelState &quot;
								+ modelState
								+ &quot; must be contained into the set of the states of the automaton associated with the replacement&quot;);

<span class="fc" id="L179">		return this.mapOutgoingTransitions</span>
<span class="fc" id="L180">				.get(new ImmutableTriple&lt;State, State, Set&lt;IGraphProposition&gt;&gt;(</span>
						modelState, destinationState, propositions));
	}

	/**
	 * returns the true if there is an outgoing transition of the replacement
	 * which has the specified source and destination states and is labeled with
	 * the specified propositions
	 * 
	 * @param modelState
	 *            the state of the replacement from which the outgoing
	 *            transitions are fired
	 * @param destinationState
	 *            the destination of the outgoing transition
	 * @param propositions
	 *            the propositions that must label the outgoing transition
	 * @return the collection of the outgoing transitions which have the
	 *         modelState as source state
	 * @throws NullPointerException
	 *             if the model state is null
	 * @throws IllegalArgumentException
	 *             if the model state is not a state of the replacement
	 *             automaton
	 */
	public boolean hasOutgoingTransition(State modelState,
			State destinationState, Set&lt;IGraphProposition&gt; propositions) {
<span class="fc" id="L206">		Preconditions.checkNotNull(modelState, &quot;The modelState cannot be null&quot;);</span>
<span class="fc" id="L207">		Preconditions.checkNotNull(destinationState,</span>
				&quot;The destination state cannot be null&quot;);
<span class="fc" id="L209">		Preconditions.checkNotNull(propositions,</span>
				&quot;The set of the propositions cannot be null&quot;);
<span class="fc" id="L211">		Preconditions</span>
<span class="fc" id="L212">				.checkArgument(</span>
<span class="fc" id="L213">						this.automaton.getStates().contains(modelState),</span>
						&quot;The modelState &quot;
								+ modelState
								+ &quot; must be contained into the set of the states of the automaton associated with the replacement&quot;);

<span class="fc" id="L218">		return !this.getOutgoingTransitions(modelState, destinationState,</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">				propositions).isEmpty();</span>
	}

	/**
	 * adds an incoming transition to the replacement
	 * 
	 * @param transition
	 *            is the transition to be added as an incoming transition
	 * @throws NullPointerException
	 *             if the transition is null
	 * @throws IllegalArgumentException
	 *             if the destination of the transition is not a state of the
	 *             automaton associated with the replacement
	 */
	public void addIncomingTransition(PluggingTransition transition) {

<span class="fc" id="L235">		Preconditions.checkNotNull(transition,</span>
				&quot;The incoming transition to be added cannot be null&quot;);
<span class="fc" id="L237">		Preconditions</span>
<span class="fc" id="L238">				.checkArgument(</span>
<span class="fc" id="L239">						this.automaton.getStates().contains(</span>
<span class="fc" id="L240">								transition.getDestination()),</span>
						&quot;The destination &quot;
<span class="fc" id="L242">								+ transition.getDestination()</span>
								+ &quot; of the incoming transition must be a state of the replacement automaton&quot;);

<span class="fc" id="L245">		this.incomingTransitions.add(transition);</span>
<span class="fc" id="L246">		this.mapIncomingTransitions.put(</span>
				new AbstractMap.SimpleEntry&lt;State, Set&lt;IGraphProposition&gt;&gt;(
<span class="fc" id="L248">						transition.getSource(), transition.getTransition()</span>
<span class="fc" id="L249">								.getPropositions()), transition);</span>

<span class="fc" id="L251">	}</span>

	/**
	 * return the set of the in-coming ports of the component
	 * 
	 * @return the incomingPorts of the component
	 */
	public Set&lt;PluggingTransition&gt; getIncomingTransitions() {
<span class="fc" id="L259">		return Collections.unmodifiableSet(incomingTransitions);</span>
	}

	/**
	 * returns the collection of incoming transitions with the specified
	 * modelState, destinationState and propositions. If no incoming transitions
	 * are associated with the modelState, destinationState and the set of
	 * propositions an empty collection is returned
	 * 
	 * @param modelState
	 *            the state of the model which is the source from which the
	 *            incoming transitions is fired
	 * @param propositions
	 *            the set of propositions that label the incoming transition
	 * @return the collection of the incoming transitions which have the
	 *         specifiedmodelState, destinationState and the set of propositions
	 * @throws NullPointerException
	 *             if the model state is null
	 * @throws IllegalArgumentException
	 *             if the model state is not a state of the replacement
	 *             automaton
	 */
	public Collection&lt;PluggingTransition&gt; getIncomingTransitions(
			State modelState, Set&lt;IGraphProposition&gt; propositions) {
<span class="fc" id="L283">		Preconditions.checkNotNull(modelState, &quot;The modelState cannot be null&quot;);</span>

<span class="fc" id="L285">		return this.mapIncomingTransitions</span>
<span class="fc" id="L286">				.get(new AbstractMap.SimpleEntry&lt;State, Set&lt;IGraphProposition&gt;&gt;(</span>
						modelState, propositions));
	}

	/**
	 * returns the true if there is an incoming transition of the replacement
	 * which has the specified destination state and is labeled with the
	 * specified propositions
	 * 
	 * @param modelState
	 *            the state of the model which is the source of the incoming
	 *            transition
	 * @param propositions
	 *            the propositions that label the replacement
	 * @return true if there is whose destination is the specified state and the
	 *         transition is labeled according to the propositions specified as
	 *         parameter
	 * @throws NullPointerException
	 *             if the model state is null
	 * @throws IllegalArgumentException
	 *             if the model state is not a state of the replacement
	 *             automaton
	 */
	public boolean hasIncomingTransition(State modelState,
			Set&lt;IGraphProposition&gt; propositions) {
<span class="fc" id="L311">		Preconditions.checkNotNull(modelState, &quot;The modelState cannot be null&quot;);</span>
<span class="fc" id="L312">		Preconditions.checkNotNull(propositions,</span>
				&quot;The set of the propositions cannot be null&quot;);

<span class="fc bfc" id="L315" title="All 2 branches covered.">		return !this.getIncomingTransitions(modelState, propositions).isEmpty();</span>
	}

	/**
	 * removes the incoming or outgoing transitions from the set of incoming or
	 * outgoing transitions
	 * 
	 * @param p
	 *            is the port to be removed
	 * @throws NullPointerException
	 *             if the port p is null
	 * @throws IllegalArgumentException
	 *             if the port is not contained into the set of incoming or
	 *             outgoing transitions
	 */
	public void removePluggingTransition(PluggingTransition p) {
<span class="fc" id="L331">		Preconditions.checkNotNull(p, &quot;The port p cannot be null&quot;);</span>
<span class="fc" id="L332">		Preconditions</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">				.checkArgument(this.getIncomingTransitions().contains(p)</span>
<span class="fc bfc" id="L334" title="All 2 branches covered.">						|| this.getOutgoingTransitions().contains(p),</span>
						&quot;The port must be contained in the set of incoming or utcoming ports&quot;);
<span class="fc bfc" id="L336" title="All 2 branches covered.">		if (this.getIncomingTransitions().contains(p)) {</span>
<span class="fc" id="L337">			this.incomingTransitions.remove(p);</span>

<span class="fc" id="L339">			this.mapIncomingTransitions.get(</span>
					new AbstractMap.SimpleEntry&lt;State, Set&lt;IGraphProposition&gt;&gt;(
<span class="fc" id="L341">							p.getDestination(), p.getTransition()</span>
<span class="fc" id="L342">									.getPropositions())).remove(p);</span>
		}
<span class="fc bfc" id="L344" title="All 2 branches covered.">		if (this.getOutgoingTransitions().contains(p)) {</span>
<span class="fc" id="L345">			this.outgoingTransitions.remove(p);</span>
<span class="fc" id="L346">			this.mapOutgoingTransitions.remove(</span>
					new ImmutableTriple&lt;State, State, Set&lt;IGraphProposition&gt;&gt;(p
<span class="fc" id="L348">							.getSource(), p.getDestination(), p.getTransition()</span>
<span class="fc" id="L349">							.getPropositions()), p);</span>

		}
<span class="fc" id="L352">	}</span>

	@Override
	public String toString() {
<span class="fc" id="L356">		return &quot;Replacement [automaton=&quot; + automaton + &quot;,\n &quot;</span>
				+ &quot;incomingTransitions=&quot; + incomingTransitions + &quot;,\n &quot;
				+ &quot;outgoingTransitions=&quot; + outgoingTransitions + &quot;\n ]&quot;;
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>
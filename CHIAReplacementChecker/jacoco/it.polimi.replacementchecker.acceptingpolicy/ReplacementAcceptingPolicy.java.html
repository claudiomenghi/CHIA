<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ReplacementAcceptingPolicy.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CHIAReplacementChecker</a> &gt; <a href="index.source.html" class="el_package">it.polimi.replacementchecker.acceptingpolicy</a> &gt; <span class="el_source">ReplacementAcceptingPolicy.java</span></div><h1>ReplacementAcceptingPolicy.java</h1><pre class="source lang-java linenums">package it.polimi.replacementchecker.acceptingpolicy;

import com.google.common.base.Preconditions;

import it.polimi.automata.state.State;
import it.polimi.constraints.components.Replacement;
import it.polimi.constraints.components.SubProperty;

/**
 * contains the accepting policy used in the replacement checking activity
 * 
 * @author Claudio Menghi
 *
 */
public class ReplacementAcceptingPolicy {

    /**
     * The sub-property under analysis
     */
    protected SubProperty subproperty;
    /**
     * The replacement under analysis
     */
    protected Replacement replacement;

    /**
     * Creates a new Replacement accepting policy
     * 
     * @param subproperty
     *            the sub-property to be considered
     * @param replacement
     *            the replacement under analysis
     */
    public ReplacementAcceptingPolicy(SubProperty subproperty,
<span class="fc" id="L35">            Replacement replacement) {</span>
<span class="fc" id="L36">        Preconditions.checkNotNull(subproperty,</span>
                &quot;the sub-property cannot be null&quot;);
<span class="fc" id="L38">        Preconditions.checkNotNull(replacement,</span>
                &quot;the replacement cannot be null&quot;);
<span class="fc" id="L40">        this.subproperty = subproperty;</span>
<span class="fc" id="L41">        this.replacement = replacement;</span>

<span class="fc" id="L43">    }</span>

    /**
     * returns the number of the next state depending on whether to reach the
     * subpropertyDestinationState and the replacementDestinationState there
     * exists an accepting state of the intersection automaton obtained from an
     * accepting state of the sub-property and to reach the
     * subpropertyDestinationState and the replacementDestinationState there
     * exists an accepting state of the intersection automaton obtained from an
     * accepting state of the replacement.
     * 
     * @param propertyAccepting
     *            is a flag that indicates whether a state of the intersection
     *            automaton obtained from an accepting state of the claim is
     *            traversed to reach the subpropertyDestinationState and the
     *            replacementDestinationState
     * @param modelAccepting
     *            is a flag that indicates whether a state of the intersection
     *            automaton obtained from an accepting state of the model is
     *            traversed to reach the subpropertyDestinationState and the
     *            replacementDestinationState
     * @param previousNumber
     *            is the number associated with the previous state
     * @param subpropertyDestinationState
     *            is the state of the sub-property that will be reached
     * @param replacementDestinationState
     *            is the state of the replacement that will be reached
     * @throws NullPointerException
     *             if one of the parameters is null
     * @throws IllegalArgumentException
     *             if the replacement state is not contained into the
     *             replacement
     * @throws IllegalArgumentException
     *             if the subProperty state is not contained into the
     *             sub-property. If the number is not included between 0 and 2
     */
    public int computeNumber(boolean modelAccepting, boolean propertyAccepting, 
            int previousNumber, State replacementDestinationState,
            State subpropertyDestinationState) {

<span class="fc" id="L83">        Preconditions.checkNotNull(replacementDestinationState,</span>
                &quot;The state of the replacement cannot be null&quot;);
<span class="fc" id="L85">        Preconditions.checkNotNull(subpropertyDestinationState,</span>
                &quot;The state of the subproperty cannot be null&quot;);
<span class="fc" id="L87">        Preconditions.checkArgument(this.replacement.getAutomaton().getStates()</span>
<span class="fc" id="L88">                .contains(replacementDestinationState), &quot;The state &quot;</span>
                + replacementDestinationState
                + &quot; is not contained into the replacement&quot;);
<span class="fc" id="L91">        Preconditions.checkArgument(this.subproperty.getAutomaton().getStates()</span>
<span class="fc" id="L92">                .contains(subpropertyDestinationState), &quot;The state &quot;</span>
                + subpropertyDestinationState
                + &quot; is not contained into the sub-property&quot;);
<span class="fc bfc" id="L95" title="All 2 branches covered.">        Preconditions.checkArgument(previousNumber &gt;= 0,</span>
                &quot;the prevNumber must be grater than 0&quot;);
<span class="fc bfc" id="L97" title="All 2 branches covered.">        Preconditions.checkArgument(previousNumber &lt;= 2,</span>
                &quot;the prevNumber must not be grater than 2&quot;);


        // if x is accepting and there exists an accepting state for the
        // property the model is accepted the value 2 is returned
<span class="fc bfc" id="L103" title="All 6 branches covered.">        if (previousNumber != 2 &amp;&amp; modelAccepting &amp;&amp;  propertyAccepting) {</span>
<span class="fc" id="L104">            return 2;</span>
        }
        

<span class="fc bfc" id="L108" title="All 4 branches covered.">        if (previousNumber == 1 &amp;&amp; propertyAccepting) {</span>
<span class="fc" id="L109">            return 2;</span>
        }
        // if x is accepting and the destination sate is accepting for the
        // property the value 2 is returned
<span class="fc bfc" id="L113" title="All 2 branches covered.">        if (previousNumber == 1</span>
<span class="fc" id="L114">                &amp;&amp; this.subproperty.getAutomaton().getAcceptStates()</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">                        .contains(subpropertyDestinationState)) {</span>
<span class="fc" id="L116">            return 2;</span>
        }
        // if x ==0 and there is a model accepting state on the reachability
        // relation and the destination state is accepting for the claim
<span class="fc bfc" id="L120" title="All 4 branches covered.">        if (previousNumber == 0</span>
                &amp;&amp; modelAccepting
<span class="fc" id="L122">                &amp;&amp; this.subproperty.getAutomaton().getAcceptStates()</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">                        .contains(subpropertyDestinationState)) {</span>
<span class="fc" id="L124">            return 2;</span>
        }
        // if x== and an accepting state of the model is contained in the run
<span class="fc bfc" id="L127" title="All 4 branches covered.">        if (previousNumber == 0 &amp;&amp; modelAccepting) {</span>
<span class="fc" id="L128">            return 1;</span>
        }
        // if x==0 and the destination is an accepting state of the model
<span class="fc bfc" id="L131" title="All 2 branches covered.">        if (previousNumber == 0</span>
<span class="fc" id="L132">                &amp;&amp; this.replacement.getAutomaton().getAcceptStates()</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">                        .contains(replacementDestinationState)) {</span>
<span class="fc" id="L134">            return 1;</span>
        }

<span class="fc bfc" id="L137" title="All 2 branches covered.">        if(previousNumber==2){</span>
<span class="fc" id="L138">            return 0;</span>
        }
        // return 0;
<span class="fc" id="L141">        return previousNumber;</span>

    }

    /**
     * returns the number to be associated with the initial state of the
     * automaton
     * 
     * @param replacementState
     *            the initial state of the model to be considered
     * @param subPropertyState
     *            the initial state of the claim to be considered
     * @return the number to be associated with the initial state of the
     *         intersection automaton
     * @throws NullPointerException
     *             if one of the parameters is null
     * @throws IllegalArgumentException
     *             if the replacement state is not contained into the
     *             replacement
     * @throws IllegalArgumentException
     *             if the subProperty state is not contained into the
     *             sub-property
     */
    public int comuteInitNumber(State replacementState, State subPropertyState) {
<span class="fc" id="L165">        Preconditions.checkNotNull(replacementState,</span>
                &quot;The state of the replacement cannot be null&quot;);
<span class="fc" id="L167">        Preconditions.checkNotNull(subPropertyState,</span>
                &quot;The state of the sub-property cannot be null&quot;);
<span class="fc" id="L169">        Preconditions.checkArgument(this.replacement.getAutomaton().getStates()</span>
<span class="fc" id="L170">                .contains(replacementState), &quot;The state &quot; + replacementState</span>
                + &quot; is not contained into the replacement&quot;);
<span class="fc" id="L172">        Preconditions.checkArgument(this.subproperty.getAutomaton().getStates()</span>
<span class="fc" id="L173">                .contains(subPropertyState), &quot;The state &quot; + subPropertyState</span>
                + &quot; is not contained into the sub-property&quot;);
<span class="fc" id="L175">        return 0;</span>
    }

    /**
     * given a state of the replacement, a state of the sub-property and the
     * previous number computes the number to be associated with the next state
     * of the automaton
     * 
     * @param replacementState
     *            the state of the replacement to be considered
     * @param subPropertyState
     *            the state of the sub-property to be considered
     * @param prevNumber
     *            the previous number
     * @return the number to be associated to the next state of the intersection
     *         automaton
     * @throws NullPointerException
     *             if one of the parameters is null
     * @throws IllegalArgumentException
     *             if the replacement state is not contained into the
     *             replacement
     * @throws IllegalArgumentException
     *             if the subProperty state is not contained into the
     *             sub-property. If the number is not included between 0 and 2
     */
    public int comuteNumber(State replacementState, State subPropertyState,
            int prevNumber) {
<span class="fc" id="L202">        Preconditions.checkNotNull(replacementState,</span>
                &quot;The state of the model cannot be null&quot;);
<span class="fc" id="L204">        Preconditions.checkNotNull(subPropertyState,</span>
                &quot;The state of the claim cannot be null&quot;);
<span class="fc" id="L206">        Preconditions.checkArgument(this.replacement.getAutomaton().getStates()</span>
<span class="fc" id="L207">                .contains(replacementState), &quot;The state &quot; + replacementState</span>
                + &quot; is not contained into the replacement&quot;);
<span class="fc" id="L209">        Preconditions.checkArgument(this.subproperty.getAutomaton().getStates()</span>
<span class="fc" id="L210">                .contains(subPropertyState), &quot;The state &quot; + subPropertyState</span>
                + &quot; is not contained into the sub-property&quot;);
<span class="fc bfc" id="L212" title="All 2 branches covered.">        Preconditions.checkArgument(prevNumber &gt;= 0,</span>
                &quot;the prevNumber must be grater than 0&quot;);
<span class="fc bfc" id="L214" title="All 2 branches covered.">        Preconditions.checkArgument(prevNumber &lt;= 2,</span>
                &quot;the prevNumber must not be grater than 2&quot;);

<span class="fc" id="L217">        int num = prevNumber;</span>

<span class="fc bfc" id="L219" title="All 2 branches covered.">        if (prevNumber == 0</span>
<span class="fc" id="L220">                &amp;&amp; replacement.getAutomaton().getAcceptStates()</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">                        .contains(replacementState)) {</span>
<span class="fc" id="L222">            num = 1;</span>
        }
<span class="fc bfc" id="L224" title="All 2 branches covered.">        if (prevNumber == 1</span>
<span class="fc" id="L225">                &amp;&amp; subproperty.getAutomaton().getAcceptStates()</span>
<span class="fc bfc" id="L226" title="All 2 branches covered.">                        .contains(subPropertyState)) {</span>
<span class="fc" id="L227">            num = 2;</span>
        }

<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (prevNumber == 2) {</span>
<span class="fc" id="L231">            num = 0;</span>
        }
<span class="fc" id="L233">        return num;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>
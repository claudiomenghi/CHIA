<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ReplacementIntersectionBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CHIAReplacementChecker</a> &gt; <a href="index.source.html" class="el_package">it.polimi.replacementchecker.intersectionbuilder</a> &gt; <span class="el_source">ReplacementIntersectionBuilder.java</span></div><h1>ReplacementIntersectionBuilder.java</h1><pre class="source lang-java linenums">package it.polimi.replacementchecker.intersectionbuilder;

import it.polimi.action.CHIAAction;
import it.polimi.automata.IBA;
import it.polimi.automata.IntersectionBA;
import it.polimi.automata.state.IntersectionStateFactory;
import it.polimi.automata.state.State;
import it.polimi.automata.state.StateFactory;
import it.polimi.automata.transition.ClaimTransitionFactory;
import it.polimi.automata.transition.ModelTransitionFactory;
import it.polimi.automata.transition.Transition;
import it.polimi.checker.ibablackboxstateremove.IBABlackBoxRemover;
import it.polimi.checker.intersection.IntersectionTransitionBuilder;
import it.polimi.checker.intersection.acceptingpolicies.KripkeAcceptingPolicy;
import it.polimi.constraints.components.Replacement;
import it.polimi.constraints.components.SubProperty;
import it.polimi.constraints.reachability.ReachabilityEntry;
import it.polimi.constraints.reachability.ReachabilityRelation;
import it.polimi.constraints.transitions.Label;
import it.polimi.constraints.transitions.LabeledPluggingTransition;
import it.polimi.constraints.transitions.PluggingTransition;
import it.polimi.replacementchecker.acceptingpolicy.ReplacementAcceptingPolicy;
import it.polimi.replacementchecker.utils.Utils;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.tuple.ImmutableTriple;
import org.apache.commons.lang3.tuple.Triple;

import rwth.i2.ltl2ba4j.model.IGraphProposition;

import com.google.common.base.Preconditions;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.SetMultimap;

/**
 * Computes the intersection between an Incomplete Buchi automaton and a Buchi
 * Automaton
 * 
 * @author Claudio Menghi
 */
public class ReplacementIntersectionBuilder extends CHIAAction&lt;IntersectionBA&gt; {

    private final static String NAME = &quot;COMPUTE INTERSECTION&quot;;
    /**
     * contains the intersection automaton generated
     */
    private IntersectionBA intersection;

    private final State greenState;
    /**
     * The yellow initial state to be injected into the over approximation
     * automaton
     */
    private final State yellowInitialState;

    /**
     * The yellow accepting state to be injected into the over approximation
     * automaton
     */
    private final State yellowAcceptingState;

    private final State redState;
    /**
     * contains the set of the visited states
     */
    private final Set&lt;Triple&lt;State, State, Integer&gt;&gt; visitedStates;

    /**
     * contains the intersection rule which is used to build the intersection
     * transitions
     */
    private final IntersectionTransitionBuilder intersectionTransitionBuilder;

    /**
     * contains a map that associate to each constraint transition the
     * corresponding model state
     */
    private final Map&lt;Transition, State&gt; mapConstrainedTransitionModelBlackBoxState;
    private final SetMultimap&lt;State, Transition&gt; mapBlackBoxStateConstrainedTransition;

    /**
     * Keeps track of the created states. For each couple of state of the model
     * and of the claim, given an integer returns the state of the intersection
     * automaton
     */
    private final Map&lt;State, Map&lt;State, Map&lt;Integer, State&gt;&gt;&gt; createdStates;

    /**
     * for each state of the model contains the corresponding states of the
     * intersection automaton
     */
    private final Map&lt;State, State&gt; intersectionStateModelStateMap;

    private SetMultimap&lt;State, State&gt; modelStateintersectionStateMap;

    private final ReachabilityRelation reachabilityRelation;

    /**
     * for each state of the claim contains the corresponding states of the
     * intersection automaton
     */
    private final Map&lt;State, State&gt; intersectionStateClaimStateMap;
    private SetMultimap&lt;State, State&gt; claimStateintersectionStateMap;

    /**
     * contains the model to be considered in the intersection procedure
     */
    private final Replacement replacement;

    /**
     * contains the claim to be considered in the intersection procedure
     */
    private final SubProperty subproperty;

    private final IBA replacementIBA;

    /**
     * contains the factory which is used to create the states of the
     * intersection automaton
     */
    private final IntersectionStateFactory intersectionStateFactory;

    /**
     * is the accepting policy to be used in the computation of the intersection
     * automaton
     */
    private final ReplacementAcceptingPolicy acceptingPolicy;

    private final boolean underApproximation;

    /**
     * crates a new {@link ReplacementIntersectionBuilder} which is in charge of
     * computing the intersection automaton
     * 
     * @param replacement
     *            is the replacement to be considered
     * @param subproperty
     *            is the sub-property to be considered
     * @param underApproximation
     *            is true if the underApproximation must be considered, false if
     *            the lower approximation must be evaluated
     * @throws NullPointerException
     *             if one of the parameters is null
     * @throws IllegalArgumentException
     *             if the accepting policy is a {@link KripkeAcceptingPolicy}
     *             and not all the states of the model are accepting
     */
    public ReplacementIntersectionBuilder(Replacement replacement,
            SubProperty subproperty, boolean underApproximation) {
<span class="fc" id="L157">        super(NAME);</span>
<span class="fc" id="L158">        Preconditions.checkNotNull(replacement,</span>
                &quot;The replacement cannot be null&quot;);
<span class="fc" id="L160">        Preconditions.checkNotNull(subproperty,</span>
                &quot;The subproperty cannot be null&quot;);
<span class="fc" id="L162">        this.greenState = new StateFactory().create(&quot;GREEN&quot;);</span>
<span class="fc" id="L163">        this.redState = new StateFactory().create(&quot;RED&quot;);</span>
<span class="fc" id="L164">        this.yellowInitialState = new StateFactory().create(&quot;YELLOW INITIAL&quot;);</span>
<span class="fc" id="L165">        this.yellowAcceptingState = new StateFactory()</span>
<span class="fc" id="L166">                .create(&quot;YELLOW ACCEPTING&quot;);</span>

<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (underApproximation) {</span>
<span class="fc" id="L169">            this.replacementIBA = new IBABlackBoxRemover(</span>
<span class="fc" id="L170">                    replacement.getAutomaton()).removeBlackBoxes();</span>
<span class="fc" id="L171">            this.reachabilityRelation = subproperty</span>
<span class="fc" id="L172">                    .getLowerReachabilityRelation();</span>
        } else {
<span class="fc" id="L174">            this.replacementIBA = replacement.getAutomaton();</span>
<span class="fc" id="L175">            this.reachabilityRelation = subproperty</span>
<span class="fc" id="L176">                    .getUpperReachabilityRelation();</span>
        }

<span class="fc" id="L179">        this.intersectionStateModelStateMap = new HashMap&lt;State, State&gt;();</span>
<span class="fc" id="L180">        this.modelStateintersectionStateMap = HashMultimap.create();</span>
<span class="fc" id="L181">        this.intersectionStateClaimStateMap = new HashMap&lt;State, State&gt;();</span>
<span class="fc" id="L182">        this.claimStateintersectionStateMap = HashMultimap.create();</span>
<span class="fc" id="L183">        this.mapBlackBoxStateConstrainedTransition = HashMultimap.create();</span>
<span class="fc" id="L184">        this.acceptingPolicy = new ReplacementAcceptingPolicy(subproperty,</span>
                replacement);
<span class="fc" id="L186">        this.intersectionTransitionBuilder = new IntersectionTransitionBuilder();</span>
<span class="fc" id="L187">        this.intersection = new IntersectionBA();</span>
<span class="fc" id="L188">        this.replacement = replacement;</span>
<span class="fc" id="L189">        this.subproperty = subproperty;</span>
<span class="fc" id="L190">        this.mapConstrainedTransitionModelBlackBoxState = new HashMap&lt;Transition, State&gt;();</span>
<span class="fc" id="L191">        this.visitedStates = new HashSet&lt;Triple&lt;State, State, Integer&gt;&gt;();</span>
<span class="fc" id="L192">        this.createdStates = new HashMap&lt;State, Map&lt;State, Map&lt;Integer, State&gt;&gt;&gt;();</span>
<span class="fc" id="L193">        this.intersectionStateFactory = new IntersectionStateFactory();</span>
<span class="fc" id="L194">        this.underApproximation = underApproximation;</span>
<span class="fc" id="L195">    }</span>

    /**
     * computes the intersection of the replacement and the sub-property
     * specified as parameters
     * 
     * @return the intersection between the replacement and the sub-property
     */
    public IntersectionBA perform() {
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if (!this.isPerformed()) {</span>
<span class="fc" id="L205">            this.updateAlphabet();</span>
<span class="fc" id="L206">            this.addingGreenState();</span>

<span class="fc bfc" id="L208" title="All 2 branches covered.">            if (!underApproximation) {</span>
<span class="fc" id="L209">                this.addingYellowInitialState();</span>
            }
<span class="fc bfc" id="L211" title="All 2 branches covered.">            for (State modelInit : this.replacementIBA.getInitialStates()) {</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">                for (State claimInit : this.subproperty.getAutomaton()</span>
<span class="fc" id="L213">                        .getInitialStates()) {</span>
<span class="fc" id="L214">                    this.computeIntersection(modelInit, claimInit,</span>
<span class="fc" id="L215">                            this.acceptingPolicy.comuteInitNumber(modelInit,</span>
                                    claimInit));
<span class="fc" id="L217">                }</span>
<span class="fc" id="L218">            }</span>
<span class="fc" id="L219">            this.addingRedState();</span>
<span class="fc bfc" id="L220" title="All 2 branches covered.">            if (!underApproximation) {</span>
<span class="fc" id="L221">                this.addingYellowAcceptingState();</span>
            }
<span class="fc" id="L223">            Multimaps.invertFrom(</span>
<span class="fc" id="L224">                    Multimaps.forMap(this.intersectionStateClaimStateMap),</span>
                    this.claimStateintersectionStateMap);
<span class="fc" id="L226">            Multimaps.invertFrom(</span>
<span class="fc" id="L227">                    Multimaps.forMap(this.intersectionStateModelStateMap),</span>
                    this.modelStateintersectionStateMap);

<span class="fc" id="L230">            Multimaps.invertFrom(Multimaps</span>
<span class="fc" id="L231">                    .forMap(this.mapConstrainedTransitionModelBlackBoxState),</span>
                    this.mapBlackBoxStateConstrainedTransition);

<span class="fc" id="L234">            this.performed();</span>
        }
<span class="fc" id="L236">        return this.intersection;</span>
    }

    /**
     * updates the alphabet of the automaton by adding the set of the characters
     * of the model and the claim
     */
    private void updateAlphabet() {
<span class="fc bfc" id="L244" title="All 2 branches covered.">        for (IGraphProposition l : this.replacementIBA.getPropositions()) {</span>
<span class="fc" id="L245">            this.intersection.addProposition(l);</span>
<span class="fc" id="L246">        }</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        for (IGraphProposition l : this.subproperty.getAutomaton()</span>
<span class="fc" id="L248">                .getPropositions()) {</span>
<span class="fc" id="L249">            this.intersection.addProposition(l);</span>
<span class="fc" id="L250">        }</span>
<span class="fc" id="L251">    }</span>

    /**
     * add the green initial state and the corresponding outgoing transitions,
     * that connect the green initial states with the states reachable through
     * transitions marked as green
     */
    private void addingGreenState() {
<span class="fc" id="L259">        this.intersection.addState(greenState);</span>
<span class="fc" id="L260">        this.intersection.addInitialState(greenState);</span>

<span class="fc bfc" id="L262" title="All 2 branches covered.">        for (LabeledPluggingTransition initTransitionSubProperty : this.subproperty</span>
<span class="fc" id="L263">                .getIncomingTransitions()) {</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">            if (initTransitionSubProperty.getLabel() == Label.G) {</span>
<span class="fc bfc" id="L265" title="All 2 branches covered.">                for (PluggingTransition initTransitionReplacement : this.replacement</span>
<span class="fc" id="L266">                        .getIncomingTransitions()) {</span>
                    // if the destination of the incoming transition of the
                    // replacement is a state of the replacement
                    // i.e., it was not a transparent state that could be
                    // removed from the replacement IBA
<span class="fc bfc" id="L271" title="All 2 branches covered.">                    if (this.replacementIBA.getStates().contains(</span>
<span class="fc" id="L272">                            initTransitionReplacement.getDestination())) {</span>
                        // if the two incoming transitions have the same source
                        // and
                        // the same label
<span class="fc bfc" id="L276" title="All 2 branches covered.">                        if (Utils.isIncomingEqual(initTransitionReplacement,</span>
                                initTransitionSubProperty)) {

<span class="fc" id="L279">                            State state = this.computeIntersection(</span>
<span class="fc" id="L280">                                    initTransitionReplacement.getDestination(),</span>
<span class="fc" id="L281">                                    initTransitionSubProperty.getDestination(),</span>
                                    0);

<span class="fc" id="L284">                            Transition transition = new ModelTransitionFactory()</span>
<span class="fc" id="L285">                                    .create();</span>
<span class="fc" id="L286">                            this.intersection.addTransition(greenState, state,</span>
                                    transition);
<span class="fc" id="L288">                            this.computeIntersection(</span>
<span class="fc" id="L289">                                    initTransitionReplacement.getDestination(),</span>
<span class="fc" id="L290">                                    initTransitionSubProperty.getDestination(),</span>
                                    0);
                        }
                    }
<span class="fc" id="L294">                }</span>
            }
<span class="fc" id="L296">        }</span>
<span class="fc" id="L297">    }</span>

    /**
     * add the green initial state and the corresponding outgoing transitions,
     * that connect the green initial states with the states reachable through
     * transitions marked as green
     */
    private void addingYellowInitialState() {
<span class="fc" id="L305">        this.intersection.addState(yellowInitialState);</span>
<span class="fc" id="L306">        this.intersection.addInitialState(yellowInitialState);</span>

<span class="fc bfc" id="L308" title="All 2 branches covered.">        for (LabeledPluggingTransition initTransitionSubProperty : this.subproperty</span>
<span class="fc" id="L309">                .getIncomingTransitions()) {</span>

<span class="fc bfc" id="L311" title="All 2 branches covered.">            if (initTransitionSubProperty.getLabel() == Label.Y) {</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">                for (PluggingTransition initTransitionReplacement : this.replacement</span>
<span class="fc" id="L313">                        .getIncomingTransitions()) {</span>
                    // if the two incoming transitions have the same source
                    // and
                    // the same label
<span class="fc bfc" id="L317" title="All 2 branches covered.">                    if (Utils.isIncomingEqual(initTransitionReplacement,</span>
                            initTransitionSubProperty)) {

<span class="fc" id="L320">                        State state = this.computeIntersection(</span>
<span class="fc" id="L321">                                initTransitionReplacement.getDestination(),</span>
<span class="fc" id="L322">                                initTransitionSubProperty.getDestination(), 0);</span>

<span class="fc" id="L324">                        Transition transition = new ModelTransitionFactory()</span>
<span class="fc" id="L325">                                .create();</span>
<span class="fc" id="L326">                        this.intersection.addTransition(</span>
                                this.yellowInitialState, state, transition);
<span class="fc" id="L328">                        this.computeIntersection(</span>
<span class="fc" id="L329">                                initTransitionReplacement.getDestination(),</span>
<span class="fc" id="L330">                                initTransitionSubProperty.getDestination(), 0);</span>
                    }

<span class="fc" id="L333">                }</span>
            }
<span class="fc" id="L335">        }</span>
<span class="fc" id="L336">    }</span>

    /**
     * Adds the red accepting state. Connects to the red accepting state all the
     * outgoing transitions of the replacement that match one of the red
     * outgoing transitions of the sub-property
     */
    private void addingRedState() {

<span class="fc" id="L345">        this.intersection.addAcceptState(redState);</span>
<span class="fc" id="L346">        this.intersection.addTransition(redState, redState,</span>
<span class="fc" id="L347">                new ModelTransitionFactory().create());</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">        for (LabeledPluggingTransition outTransitionSubProperty : this.subproperty</span>
<span class="fc" id="L349">                .getOutgoingTransitions()) {</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">            if (outTransitionSubProperty.getLabel() == Label.R) {</span>
<span class="fc bfc" id="L351" title="All 2 branches covered.">                for (PluggingTransition outTransitionReplacement : this.replacement</span>
<span class="fc" id="L352">                        .getOutgoingTransitions()) {</span>

                    // if the source of the outgoing transition of the
                    // replacement is a state of the replacement
                    // i.e., it was not a transparent state that could be
                    // removed from the replacement IBA
<span class="fc bfc" id="L358" title="All 2 branches covered.">                    if (this.replacementIBA.getStates().contains(</span>
<span class="fc" id="L359">                            outTransitionReplacement.getSource())) {</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">                        if (Utils.isOutgoingEqual(outTransitionReplacement,</span>
                                outTransitionSubProperty)) {
                            // getting the created intersection states
<span class="fc" id="L363">                            Set&lt;State&gt; outIntersectionStates = this</span>
<span class="fc" id="L364">                                    .getIntersectionStates(</span>
                                            outTransitionReplacement
<span class="fc" id="L366">                                                    .getSource(),</span>
                                            outTransitionSubProperty
<span class="fc" id="L368">                                                    .getSource());</span>
                            // connecting the the intersection states
                            // associated with the source of the outgoing
                            // transitions to the red state
<span class="fc bfc" id="L372" title="All 2 branches covered.">                            for (State outState : outIntersectionStates) {</span>
<span class="fc" id="L373">                                this.intersection.addTransition(outState,</span>
                                        redState,
<span class="fc" id="L375">                                        new ModelTransitionFactory().create());</span>

<span class="fc" id="L377">                            }</span>
                        }
                    }
<span class="fc" id="L380">                }</span>
            }
<span class="fc" id="L382">        }</span>
<span class="fc" id="L383">    }</span>

    /**
     * adds the yellow accepting state and its incoming transitions to the
     * intersection automaton
     */
    private void addingYellowAcceptingState() {

<span class="fc" id="L391">        this.intersection.addAcceptState(this.yellowAcceptingState);</span>
<span class="fc" id="L392">        this.intersection.addTransition(this.yellowAcceptingState,</span>
                this.yellowAcceptingState,
<span class="fc" id="L394">                new ModelTransitionFactory().create());</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">        for (LabeledPluggingTransition outTransitionSubProperty : this.subproperty</span>
<span class="fc" id="L396">                .getOutgoingTransitions()) {</span>
<span class="fc bfc" id="L397" title="All 2 branches covered.">            if (outTransitionSubProperty.getLabel() == Label.Y) {</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">                for (PluggingTransition outTransitionReplacement : this.replacement</span>
<span class="fc" id="L399">                        .getOutgoingTransitions()) {</span>

<span class="fc bfc" id="L401" title="All 2 branches covered.">                    if (Utils.isOutgoingEqual(outTransitionReplacement,</span>
                            outTransitionSubProperty)) {
                        // getting the created intersection states
<span class="fc" id="L404">                        Set&lt;State&gt; outIntersectionStates = this</span>
<span class="fc" id="L405">                                .getIntersectionStates(</span>
<span class="fc" id="L406">                                        outTransitionReplacement.getSource(),</span>
<span class="fc" id="L407">                                        outTransitionSubProperty.getSource());</span>
                        // connecting the green and the intersection states
                        // associated with the destination of the incoming
                        // transition
<span class="fc bfc" id="L411" title="All 2 branches covered.">                        for (State outState : outIntersectionStates) {</span>
<span class="fc" id="L412">                            this.intersection.addTransition(outState,</span>
                                    this.yellowAcceptingState,
<span class="fc" id="L414">                                    new ModelTransitionFactory().create());</span>

<span class="fc" id="L416">                        }</span>
                    }

<span class="fc" id="L419">                }</span>
            }
<span class="fc" id="L421">        }</span>
<span class="fc" id="L422">    }</span>

    /**
     * is a recursive procedure that computes the intersection of this automaton
     * and the automaton a2
     * 
     * @param replacementState
     *            is the current state of the model under analysis
     * @param subpropertyState
     *            is the current state of the claim under analysis
     * @param number
     *            is the number of the state under analysis
     * @return the state that is generated
     */
    private State computeIntersection(State replacementState,
            State subpropertyState, int number) {
<span class="fc" id="L438">        Preconditions.checkArgument(this.replacementIBA.getStates().contains(</span>
                replacementState));
<span class="fc" id="L440">        Preconditions.checkArgument(this.subproperty.getAutomaton().getStates()</span>
<span class="fc" id="L441">                .contains(subpropertyState));</span>

        // if the state has been already been visited
<span class="fc bfc" id="L444" title="All 2 branches covered.">        if (this.checkVisitedStates(replacementState, subpropertyState, number)) {</span>
<span class="fc" id="L445">            return this.createdStates.get(replacementState)</span>
<span class="fc" id="L446">                    .get(subpropertyState).get(number);</span>
        } else {

<span class="fc" id="L449">            State intersectionState = this.intersectionStateFactory.create(</span>
                    replacementState, subpropertyState, number);
<span class="fc" id="L451">            this.addStateIntoTheIntersectionAutomaton(intersectionState,</span>
                    replacementState, subpropertyState, number);
<span class="fc" id="L453">            this.updateVisitedStates(intersectionState, replacementState,</span>
                    subpropertyState, number);

            // for each transition in the automaton that exits the model state
<span class="fc bfc" id="L457" title="All 2 branches covered.">            for (Transition modelTransition : this.replacementIBA</span>
<span class="fc" id="L458">                    .getOutTransitions(replacementState)) {</span>
                // for each transition in the extended automaton whit exit the
                // claim
                // state
<span class="fc bfc" id="L462" title="All 2 branches covered.">                for (Transition claimTransition : this.subproperty</span>
<span class="fc" id="L463">                        .getAutomaton().getOutTransitions(subpropertyState)) {</span>

                    // if the two transitions are compatible
<span class="fc bfc" id="L466" title="All 2 branches covered.">                    if (this.intersectionTransitionBuilder.isCompatible(</span>
                            modelTransition, claimTransition)) {

                        // creates a new state made by the states s1next and s2
                        // next
<span class="fc" id="L471">                        State nextModelState = this.replacementIBA</span>
<span class="fc" id="L472">                                .getTransitionDestination(modelTransition);</span>
<span class="fc" id="L473">                        State nextClaimState = this.subproperty.getAutomaton()</span>
<span class="fc" id="L474">                                .getTransitionDestination(claimTransition);</span>

<span class="fc" id="L476">                        int nextNumber = this.acceptingPolicy.comuteNumber(</span>
                                nextModelState, nextClaimState, number);

<span class="fc" id="L479">                        State nextIntersectionState = this.computeIntersection(</span>
                                nextModelState, nextClaimState, nextNumber);

<span class="fc" id="L482">                        Transition t = this.intersectionTransitionBuilder</span>
<span class="fc" id="L483">                                .getIntersectionTransition(modelTransition,</span>
                                        claimTransition);
<span class="fc" id="L485">                        this.intersection.addTransition(intersectionState,</span>
                                nextIntersectionState, t);
                    }
<span class="fc" id="L488">                }</span>
<span class="fc" id="L489">            }</span>

<span class="fc" id="L491">            this.checkReachabilityTransitions(intersectionState,</span>
                    replacementState, subpropertyState, number);
            // if the current state of the extended automaton is black box
<span class="fc bfc" id="L494" title="All 2 branches covered.">            if (this.replacementIBA.isBlackBox(replacementState)) {</span>
<span class="fc" id="L495">                computeBlackBox(replacementState, subpropertyState, number,</span>
                        intersectionState);
            }
<span class="fc" id="L498">            return intersectionState;</span>
        }
    }

    /**
     * check the presence of the reachability transitions, i.e., the transitions
     * generated by the reachability relation
     * 
     * @param intersectionState
     *            is the intersection state from which the reachability
     *            transition starts
     * @param modelState
     *            is the state of the model which corresponds to the
     *            intersection state, i.e., the current state of the model under
     *            analysis
     * @param claimState
     *            is the state of the claim which corresponds to the
     *            intersection state, i.e., the current state of the claim under
     *            analysis
     * @param number
     *            is the number associated with the intersection state
     */
    private void checkReachabilityTransitions(State intersectionState,
            State modelState, State claimState, int number) {
<span class="fc" id="L522">        Preconditions.checkNotNull(intersectionState,</span>
                &quot;The intersection state under analysis cannot be null&quot;);
<span class="fc" id="L524">        Preconditions.checkNotNull(modelState,</span>
                &quot;Is the state of the model which is under analysis&quot;);
<span class="fc" id="L526">        Preconditions.checkNotNull(claimState,</span>
                &quot;Is the state of the claim which is under analysis&quot;);

<span class="fc" id="L529">        Collection&lt;ReachabilityEntry&gt; subPropertyReachabilityEntries = this.reachabilityRelation</span>
<span class="fc" id="L530">                .get(claimState);</span>

<span class="fc bfc" id="L532" title="All 2 branches covered.">        for (ReachabilityEntry subpropertyReachabilityEntry : subPropertyReachabilityEntries) {</span>
<span class="fc" id="L533">            LabeledPluggingTransition outgoingTransition = subpropertyReachabilityEntry</span>
<span class="fc" id="L534">                    .getOutgoingTransition();</span>

<span class="fc bfc" id="L536" title="All 2 branches covered.">            if (this.replacement.hasOutgoingTransition(modelState,</span>
<span class="fc" id="L537">                    outgoingTransition.getDestination(), outgoingTransition</span>
<span class="fc" id="L538">                            .getTransition().getPropositions())) {</span>

<span class="fc" id="L540">                LabeledPluggingTransition coloredReachabilityIncomingTransition = subpropertyReachabilityEntry</span>
<span class="fc" id="L541">                        .getIncomingTransition();</span>

<span class="fc bfc" id="L543" title="All 2 branches covered.">                for (PluggingTransition replacementIncomingTransition : this.replacement</span>
<span class="fc" id="L544">                        .getIncomingTransitions(</span>
                                coloredReachabilityIncomingTransition
<span class="fc" id="L546">                                        .getSource(),</span>
                                coloredReachabilityIncomingTransition
<span class="fc" id="L548">                                        .getTransition().getPropositions())) {</span>
<span class="fc" id="L549">                    int nextnumber = this.acceptingPolicy.computeNumber(</span>
<span class="fc" id="L550">                            subpropertyReachabilityEntry.isModelAccepting(),</span>
<span class="fc" id="L551">                            subpropertyReachabilityEntry.isClaimAccepting(),</span>
                            number, replacementIncomingTransition
<span class="fc" id="L553">                                    .getDestination(),</span>
                            subpropertyReachabilityEntry
<span class="fc" id="L555">                                    .getIncomingTransition().getDestination());</span>

<span class="fc" id="L557">                    State nextModelState = replacementIncomingTransition</span>
<span class="fc" id="L558">                            .getDestination();</span>
<span class="fc" id="L559">                    State nextClaimState = subpropertyReachabilityEntry</span>
<span class="fc" id="L560">                            .getIncomingTransition().getDestination();</span>
<span class="fc" id="L561">                    State nextState = this.computeIntersection(nextModelState,</span>
                            nextClaimState, nextnumber);

<span class="fc" id="L564">                    Transition t = new ModelTransitionFactory().create();</span>
<span class="fc" id="L565">                    this.intersection.addTransition(intersectionState,</span>
                            nextState, t);
<span class="fc" id="L567">                }</span>
            }
<span class="fc" id="L569">        }</span>
<span class="fc" id="L570">    }</span>

    /**
     * @param replacementState
     * @param subPropertyState
     * @param number
     * @param previousIntersectionState
     */
    private void computeBlackBox(State replacementState,
            State subPropertyState, int number, State previousIntersectionState) {

        // for each transition in the automaton a2
<span class="fc bfc" id="L582" title="All 2 branches covered.">        for (Transition claimTransition : this.subproperty.getAutomaton()</span>
<span class="fc" id="L583">                .getOutTransitions(subPropertyState)) {</span>

<span class="fc" id="L585">            State nextClaimState = this.subproperty.getAutomaton()</span>
<span class="fc" id="L586">                    .getTransitionDestination(claimTransition);</span>

<span class="fc" id="L588">            int nextNumber = this.acceptingPolicy.comuteNumber(</span>
                    replacementState, nextClaimState, number);

<span class="fc" id="L591">            State nextState = this.computeIntersection(replacementState,</span>
                    nextClaimState, nextNumber);

<span class="fc" id="L594">            Transition intersectionTransition = new ClaimTransitionFactory()</span>
<span class="fc" id="L595">                    .create(claimTransition.getPropositions());</span>

<span class="fc" id="L597">            this.intersection.addConstrainedTransition(</span>
                    previousIntersectionState, nextState,
                    intersectionTransition);

<span class="fc" id="L601">            this.mapConstrainedTransitionModelBlackBoxState.put(</span>
                    intersectionTransition, replacementState);

<span class="fc" id="L604">        }</span>
<span class="fc" id="L605">    }</span>

    private void updateVisitedStates(State intersectionState, State modelState,
            State claimState, int number) {
<span class="fc" id="L609">        Preconditions</span>
<span class="fc" id="L610">                .checkNotNull(modelState, &quot;The model state cannot be null&quot;);</span>
<span class="fc" id="L611">        Preconditions</span>
<span class="fc" id="L612">                .checkNotNull(claimState, &quot;The claim state cannot be null&quot;);</span>

<span class="fc" id="L614">        this.visitedStates.add(new ImmutableTriple&lt;State, State, Integer&gt;(</span>
<span class="fc" id="L615">                modelState, claimState, number));</span>

<span class="fc bfc" id="L617" title="All 2 branches covered.">        if (!this.createdStates.containsKey(modelState)) {</span>
<span class="fc" id="L618">            Map&lt;State, Map&lt;Integer, State&gt;&gt; map1 = new HashMap&lt;State, Map&lt;Integer, State&gt;&gt;();</span>
<span class="fc" id="L619">            Map&lt;Integer, State&gt; map2 = new HashMap&lt;Integer, State&gt;();</span>
<span class="fc" id="L620">            map2.put(number, intersectionState);</span>
<span class="fc" id="L621">            map1.put(claimState, map2);</span>
<span class="fc" id="L622">            this.createdStates.put(modelState, map1);</span>

<span class="fc" id="L624">        } else {</span>
<span class="fc bfc" id="L625" title="All 2 branches covered.">            if (!this.createdStates.get(modelState).containsKey(claimState)) {</span>
<span class="fc" id="L626">                Map&lt;Integer, State&gt; map2 = new HashMap&lt;Integer, State&gt;();</span>
<span class="fc" id="L627">                map2.put(number, intersectionState);</span>
<span class="fc" id="L628">                this.createdStates.get(modelState).put(claimState, map2);</span>
<span class="fc" id="L629">            } else {</span>
<span class="fc" id="L630">                this.createdStates.get(modelState).get(claimState)</span>
<span class="fc" id="L631">                        .put(new Integer(number), intersectionState);</span>
            }
        }

<span class="fc" id="L635">        this.intersectionStateModelStateMap.put(intersectionState, modelState);</span>
<span class="fc" id="L636">        this.intersectionStateClaimStateMap.put(intersectionState, claimState);</span>
<span class="fc" id="L637">    }</span>

    private void addStateIntoTheIntersectionAutomaton(State intersectionState,
            State modelState, State claimState, int number) {

<span class="fc" id="L642">        this.intersection.addState(intersectionState);</span>
<span class="fc bfc" id="L643" title="All 2 branches covered.">        if (this.replacementIBA.getInitialStates().contains(modelState)</span>
<span class="fc" id="L644">                &amp;&amp; this.subproperty.getAutomaton().getInitialStates()</span>
<span class="fc bfc" id="L645" title="All 2 branches covered.">                        .contains(claimState)) {</span>
            // if (this.acceptingPolicy instanceof KripkeAcceptingPolicy) {
            // this.intersection.addInitialState(intersectionState);
            // } else {
<span class="fc bfc" id="L649" title="All 2 branches covered.">            if (number == 0) {</span>
<span class="fc" id="L650">                this.intersection.addInitialState(intersectionState);</span>
            }
            // }

        }
<span class="fc bfc" id="L655" title="All 2 branches covered.">        if (number == 2) {</span>
<span class="fc" id="L656">            this.intersection.addAcceptState(intersectionState);</span>
        }
<span class="fc bfc" id="L658" title="All 2 branches covered.">        if (this.replacementIBA.isBlackBox(modelState)) {</span>
<span class="fc" id="L659">            this.intersection.addMixedState(intersectionState);</span>
        }

<span class="fc" id="L662">        this.intersectionStateModelStateMap.put(intersectionState, modelState);</span>
<span class="fc" id="L663">        this.intersectionStateClaimStateMap.put(intersectionState, claimState);</span>
<span class="fc" id="L664">    }</span>

    private boolean checkVisitedStates(State modelState, State claimState,
            int number) {
<span class="fc" id="L668">        Preconditions</span>
<span class="fc" id="L669">                .checkNotNull(modelState, &quot;The model state cannot be null&quot;);</span>
<span class="fc" id="L670">        Preconditions</span>
<span class="fc" id="L671">                .checkNotNull(claimState, &quot;The claim state cannot be null&quot;);</span>

<span class="fc" id="L673">        return this.visitedStates</span>
<span class="fc" id="L674">                .contains(new ImmutableTriple&lt;State, State, Integer&gt;(</span>
<span class="fc" id="L675">                        modelState, claimState, number));</span>
    }

    /**
     * returns the intersection automaton
     * 
     * @return the intersection automaton which have been computed
     * @throws IllegalStateException
     *             if the intersection has still to be computed
     */
    public IntersectionBA getIntersectionAutomaton() {
<span class="fc" id="L686">        Preconditions</span>
<span class="fc" id="L687">                .checkState(</span>
<span class="fc" id="L688">                        this.isPerformed(),</span>
                        &quot;it is necessary to compute the intersection before returning the intersection automaton&quot;);
<span class="fc" id="L690">        return this.intersection;</span>

    }

    protected Set&lt;State&gt; getIntersectionStates(State replacementState,
            State subpropertyState) {
<span class="fc" id="L696">        Preconditions.checkNotNull(subpropertyState,</span>
                &quot;The state of the claim cannot be null&quot;);
<span class="fc" id="L698">        Preconditions.checkNotNull(replacementState,</span>
                &quot;The state of the model cannot be null&quot;);
<span class="fc" id="L700">        Preconditions.checkArgument(this.subproperty.getAutomaton().getStates()</span>
<span class="fc" id="L701">                .contains(subpropertyState), &quot;The state &quot; + subpropertyState</span>
                + &quot; is not contained into the set of the states of the claim&quot;);
<span class="fc" id="L703">        Preconditions</span>
<span class="fc" id="L704">                .checkArgument(</span>
<span class="fc" id="L705">                        this.replacementIBA.getStates().contains(</span>
                                replacementState),
                        &quot;The state &quot;
                                + replacementState
                                + &quot; is not contained into the set of the states of the model&quot;);
<span class="fc bfc" id="L710" title="All 2 branches covered.">        if (!createdStates.containsKey(replacementState)) {</span>
<span class="fc" id="L711">            return new HashSet&lt;State&gt;();</span>
        } else {
<span class="fc bfc" id="L713" title="All 2 branches covered.">            if (!createdStates.get(replacementState).containsKey(</span>
                    subpropertyState)) {
<span class="fc" id="L715">                return new HashSet&lt;State&gt;();</span>
            } else {
<span class="fc" id="L717">                return Collections.unmodifiableSet(new HashSet&lt;State&gt;(</span>
<span class="fc" id="L718">                        createdStates.get(replacementState)</span>
<span class="fc" id="L719">                                .get(subpropertyState).values()));</span>
            }
        }
    }

    /**
     * returns true if the state of the intersection is the green state
     * 
     * @param intersectionState
     *            is the intersection state to be considered
     * @return true if the state is the green state
     */
    public boolean isGreenState(State intersectionState) {
<span class="fc" id="L732">        return this.greenState.equals(intersectionState);</span>
    }

    /**
     * returns true if the state of the intersection is the red state
     * 
     * @param intersectionState
     *            is the intersection state to be considered
     * @return true if the state is the red state
     */
    public boolean isRedState(State intersectionState) {
<span class="fc" id="L743">        return this.redState.equals(intersectionState);</span>
    }

    /**
     * returns the state of the model associated with the specified intersection
     * state. No intersection states are associated with the green and the red
     * state.
     * 
     * 
     * @param intersectionState
     *            the intersection state to be considered
     * @return the state of the model associated with the specified intersection
     *         state
     * @throws NullPointerException
     *             if the state to be considered is null
     * @throws IllegalArgumentException
     *             if the state is not a state of the intersection automaton. If
     *             the state is the green initial, the yellow initial, the red
     *             accepting or the yellow accepting state
     */
    public State getModelState(State intersectionState) {
<span class="fc" id="L764">        Preconditions</span>
<span class="fc" id="L765">                .checkNotNull(intersectionState,</span>
                        &quot;The state of the intersection automaton to be considered cannot be null&quot;);
<span class="fc" id="L767">        Preconditions</span>
<span class="fc" id="L768">                .checkArgument(</span>
<span class="fc" id="L769">                        this.intersection.getStates().contains(</span>
                                intersectionState),
                        &quot;The state to be considered must be a state of the intersection automaton&quot;);
<span class="fc" id="L772">        Preconditions</span>
<span class="fc bfc" id="L773" title="All 2 branches covered.">                .checkArgument(!this.greenState.equals(intersectionState),</span>
                        &quot;It is not possible to invoke this method over the green initial state&quot;);
<span class="fc" id="L775">        Preconditions</span>
<span class="fc bfc" id="L776" title="All 2 branches covered.">                .checkArgument(!this.redState.equals(intersectionState),</span>
                        &quot;It is not possible to invoke this method over the red accepting state&quot;);
<span class="fc" id="L778">        Preconditions</span>
<span class="fc" id="L779">                .checkArgument(</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">                        !this.yellowInitialState.equals(intersectionState),</span>
                        &quot;It is not possible to invoke this method over the yellow initial state&quot;);
<span class="fc" id="L782">        Preconditions</span>
<span class="fc" id="L783">                .checkArgument(</span>
<span class="fc bfc" id="L784" title="All 2 branches covered.">                        !this.yellowAcceptingState.equals(intersectionState),</span>
                        &quot;It is not possible to invoke this method over the yellow accepting state&quot;);

<span class="fc" id="L787">        return this.intersectionStateModelStateMap.get(intersectionState);</span>

    }

    /**
     * @return the yellowInitialState
     */
    public State getYellowInitialState() {
<span class="fc bfc" id="L795" title="All 2 branches covered.">        if (this.underApproximation) {</span>
<span class="fc" id="L796">            throw new IllegalStateException(</span>
                    &quot;The under approximation does not contain any yellow initial state&quot;);
        }
<span class="fc" id="L799">        return yellowInitialState;</span>
    }

    /**
     * @return the greenState
     */
    public State getGreenState() {
<span class="fc" id="L806">        return greenState;</span>
    }

    /**
     * @return the yellowAcceptingState
     */
    public State getYellowAcceptingState() {
<span class="fc bfc" id="L813" title="All 2 branches covered.">        if (this.underApproximation) {</span>
<span class="fc" id="L814">            throw new IllegalStateException(</span>
                    &quot;The under approximation does not contain any yellow accepting state&quot;);
        }
<span class="fc" id="L817">        return yellowAcceptingState;</span>
    }

    /**
     * @return the redState
     */
    public State getRedState() {
<span class="fc" id="L824">        return redState;</span>
    }

    /**
     * @return the mapModelStateIntersectionTransitions
     */
    public Map&lt;Transition, State&gt; getIntersectionTransitionsBlackBoxStatesMap() {
<span class="fc" id="L831">        return Collections</span>
<span class="fc" id="L832">                .unmodifiableMap(mapConstrainedTransitionModelBlackBoxState);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>IBARandomGenerator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CHIAScalabilityEvaluator</a> &gt; <a href="index.source.html" class="el_package">it.polimi.chia.scalability.randomGenerators</a> &gt; <span class="el_source">IBARandomGenerator.java</span></div><h1>IBARandomGenerator.java</h1><pre class="source lang-java linenums">package it.polimi.chia.scalability.randomGenerators;

import it.polimi.action.CHIAAction;
import it.polimi.automata.BA;
import it.polimi.automata.IBA;
import it.polimi.automata.state.State;
import it.polimi.automata.state.StateFactory;
import it.polimi.automata.transition.ModelTransitionFactory;
import it.polimi.automata.transition.Transition;
import it.polimi.constraints.components.Replacement;
import it.polimi.constraints.transitions.PluggingTransition;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;

import rwth.i2.ltl2ba4j.model.IGraphProposition;

import com.google.common.base.Preconditions;
import com.google.common.collect.BiMap;
import com.google.common.collect.HashBiMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Iterables;
import com.google.common.collect.Maps;

/**
 * In the experiments, both the IBAs and the replacements of the transparent
 * states are extracted from the randomly generated BAs. The idea is to randomly
 * encapsulate parts of the BAs into transparent states. The encapsulated
 * automata and the corresponding incoming and outgoing transitions are the
 * replacements associated with the transparent states, while the IBA is the
 * automaton obtained by replacing the encapsulated parts with the corresponding
 * transparent states. The transparent state density ($t=|T|/|Q|$) specifies the
 * number of transparent states which must be inserted into the BA. The
 * replacement density ($r=(\sum_{t \in T}|Q_t|)/|Q|$) specifies the number of
 * states of the automaton to be injected inside the replacement of each
 * transparent state.
 * 
 * @author Claudio Menghi
 *
 */
public class IBARandomGenerator extends CHIAAction&lt;IBA&gt; {

	/**
	 * contains the number of transparent states to be used in the IBA
	 * computation
	 */
	private int numBlackBoxStates;

	/**
	 * the number of states of the BA to be encapsulated into a replacement
	 */
	private int numEncapsulatedStates;

	/**
	 * the BA which must be used in the computation of the IBA
	 */
	private BA ba;

	/**
	 * the map specifies for each transparent state the corresponding
	 * replacement
	 */
	private BiMap&lt;State, Replacement&gt; blackBoxStateReplacementMap;
	
	/**
	 * the map specifies for each transparent state the corresponding
	 * replacement
	 */
	private final BiMap&lt;State, Replacement&gt; blackBoxStateNonEmptyReplacementMap;

	/**
	 * if a state of the BA is encapsulated into the replacement it maps the
	 * state to the corresponding replacement
	 */
	private Map&lt;State, Replacement&gt; stateReplacementMap;

	/**
	 * the IBA that is computed starting from the BA
	 */
	private IBA iba;

	/**
	 * the state factory used to create the transparent states
	 */
	private StateFactory stateFactory;

	private static final String ACTION_NAME = &quot;IBA Random Generation&quot;;

	/**
	 * 
	 * @param ba
	 *            is the BA from which the IBA must be extracted
	 * @param transparentStateDensity
	 *            is the density of the transparent states to be considered in
	 *            the IBA computation
	 * @param replacementDensity
	 *            specifies the number of states of the automaton to be injected
	 *            inside the replacement of each transparent state.
	 * @param stateFactory
	 *            is the factory to be used in the creation of the transparent
	 *            states
	 * @throws NullPointerException
	 *             if the BA, the state factory or the randomGenerator is null
	 * @throws IllegalArgumentException
	 *             if the transparent state density is not grater than or equal
	 *             to zero
	 * @throws IllegalArgumentException
	 *             if the replacement density is not grater than or equal to
	 *             zero
	 * @throws IllegalArgumentException
	 *             if the transparentStateDensity multiplied per the number of
	 *             states of the automaton multiplied for the replacement
	 *             density multiplied for the number of the state of the
	 *             automaton is not less than the number of the states of the
	 *             automaton
	 */
	public IBARandomGenerator(BA ba, StateFactory stateFactory,
			double transparentStateDensity, double replacementDensity) {
<span class="fc" id="L126">		super(ACTION_NAME);</span>
<span class="fc" id="L127">		Preconditions.checkNotNull(ba, &quot;The BA cannot be null&quot;);</span>
<span class="fc" id="L128">		Preconditions.checkNotNull(stateFactory,</span>
				&quot;The state factory cannot be null&quot;);
<span class="pc bpc" id="L130" title="2 of 4 branches missed.">		Preconditions</span>
<span class="fc" id="L131">				.checkArgument(transparentStateDensity &gt;= 0 &amp;&amp; replacementDensity&lt;=1,</span>
						&quot;The transparent state density must be grater than or equal to zero and less than or equal to 1&quot;);
<span class="pc bpc" id="L133" title="2 of 4 branches missed.">		Preconditions.checkArgument(replacementDensity &gt;= 0 &amp;&amp; replacementDensity&lt;=1,</span>
				&quot;The replacement density must be grater than or equal to zero and less than or equal to 1&quot;);

		
<span class="fc" id="L137">		Preconditions</span>
<span class="fc" id="L138">				.checkArgument(</span>
<span class="fc" id="L139">						Math.abs(Math.abs(transparentStateDensity)</span>
<span class="fc" id="L140">								* ba.getStates().size()</span>
<span class="fc" id="L141">								+ Math.abs(replacementDensity)</span>
<span class="fc" id="L142">								* ba.getStates().size()) &lt;= ba.getStates()</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">								.size(),</span>
						&quot;The transparentStateDensity * ba.getStates().size() * replacementDensity* ba.getStates().size() &lt;= ba.getStates().size(): &quot;
<span class="fc" id="L145">								+ Math.abs(Math.abs(transparentStateDensity)</span>
<span class="fc" id="L146">										* ba.getStates().size()</span>
<span class="fc" id="L147">										+ Math.abs(replacementDensity)</span>
<span class="fc" id="L148">										* ba.getStates().size())</span>
								+ &quot;&lt;&quot;
<span class="fc" id="L150">								+ ba.getStates().size());</span>

<span class="fc" id="L152">		this.numBlackBoxStates = (int) Math.abs(ba.getStates().size()</span>
				* transparentStateDensity);
<span class="fc" id="L154">		this.ba = ba;</span>
<span class="fc" id="L155">		this.blackBoxStateReplacementMap = HashBiMap.create();</span>
<span class="fc" id="L156">		this.blackBoxStateNonEmptyReplacementMap=HashBiMap.create();</span>
<span class="fc" id="L157">		this.stateReplacementMap = new HashMap&lt;State, Replacement&gt;();</span>
<span class="fc" id="L158">		this.numEncapsulatedStates = (int) Math.abs((ba.getStates().size() - 1)</span>
				* replacementDensity);
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">		Preconditions.checkArgument(numEncapsulatedStates&lt;=ba.getStates().size(), &quot;The number of the encapsultated states must be less than or equal to the states of the BA&quot;);</span>
<span class="fc" id="L161">		this.stateFactory = stateFactory;</span>
<span class="fc" id="L162">	}</span>

	/**
	 * returns the randomly generated IBA
	 * 
	 * @return the randomly generated IBA
	 */
	public IBA perform() {

		// creates the IBA to be returned
<span class="fc" id="L172">		this.iba = new IBA(new ModelTransitionFactory());</span>

		// adds the propositions to the IBA
<span class="fc" id="L175">		this.addPropositions();</span>

		// creates the transparent states and the corresponding replacements
<span class="fc" id="L178">		this.createBlackBoxStatesAndReplacements();</span>

<span class="fc" id="L180">		Set&lt;State&gt; setOfTheInjectedStates=new HashSet&lt;State&gt;();</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">		if(this.blackBoxStateReplacementMap.keySet().size()&gt;0){</span>
<span class="fc" id="L182">			List&lt;State&gt; baStates = new ArrayList&lt;State&gt;(ba.getStates());</span>
<span class="fc" id="L183">			Collections.shuffle(baStates);</span>
<span class="fc" id="L184">			 setOfTheInjectedStates = ImmutableSet.copyOf(Iterables.limit(baStates, numEncapsulatedStates));</span>

			// adds the subset of states to the replacement
<span class="fc" id="L187">			this.addStatesToTheReplacements(setOfTheInjectedStates);</span>

		}
		
		// adds the remaining states to the IBA as regular states
<span class="fc" id="L192">		Set&lt;State&gt; remainingBAStates = new HashSet&lt;State&gt;(ba.getStates());</span>
<span class="fc" id="L193">		remainingBAStates.removeAll(setOfTheInjectedStates);</span>
<span class="fc" id="L194">		this.addStatesToTheIBA(remainingBAStates);</span>

		// generates the transition between the different states
<span class="fc" id="L197">		this.generateTransitions();</span>

<span class="fc" id="L199">		this.performed();</span>
<span class="fc" id="L200">		return iba;</span>
	}

	/**
	 * adds the propositions to the BA to be returned
	 */
	private void addPropositions() {
<span class="fc bfc" id="L207" title="All 2 branches covered.">		for (IGraphProposition proposition : this.ba.getPropositions()) {</span>
<span class="fc" id="L208">			this.iba.addProposition(proposition);</span>
<span class="fc" id="L209">		}</span>
<span class="fc" id="L210">	}</span>

	/**
	 * adds the state to the replacement
	 * 
	 * @param states
	 *            the set of states to be added to the replacements
	 * @throws NullPointerException
	 *             if states is null
	 * @throws IllegalArgumentException
	 *             if the set of state is not included in the set of states of
	 *             the BA
	 */
	private void addStatesToTheReplacements(Set&lt;State&gt; states) {
<span class="fc" id="L224">		Preconditions.checkNotNull(states,</span>
				&quot;The set of the states cannot be null&quot;);
<span class="fc" id="L226">		Preconditions</span>
<span class="fc" id="L227">				.checkArgument(</span>
<span class="fc" id="L228">						this.ba.getStates().containsAll(states),</span>
						&quot;The set of states must be contained into the set of the states of the automaton&quot;);
<span class="fc" id="L230">		Preconditions</span>
<span class="fc" id="L231">				.checkArgument(</span>
<span class="fc" id="L232">						this.blackBoxStateReplacementMap.keySet().size()</span>
<span class="fc" id="L233">								+ numEncapsulatedStates &lt;= this.ba.getStates()</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">								.size(),</span>
						&quot;The number of the transparent states (&quot;
<span class="fc" id="L236">								+ this.blackBoxStateReplacementMap.keySet()</span>
<span class="fc" id="L237">										.size()</span>
								+ &quot;)\n plus by the number of states added inside each replacement (&quot;
								+ numEncapsulatedStates
								+ &quot;) \n must be less than or equal the numebr of states of the Ba from which the IBA must be extracted(&quot;
<span class="fc" id="L241">								+ this.ba.getStates() + &quot;)&quot;);</span>

		

<span class="fc" id="L245">		List&lt;State&gt; blackBoxStates = new ArrayList&lt;State&gt;(</span>
<span class="fc" id="L246">				this.blackBoxStateReplacementMap.keySet());</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">		for(State blackBoxState: blackBoxStates){</span>
<span class="fc" id="L248">			iba.addBlackBoxState(blackBoxState);</span>
<span class="fc" id="L249">		}</span>
		
<span class="fc" id="L251">		Iterator&lt;State&gt; baStatesIterator = states.iterator();</span>

<span class="fc" id="L253">		Random random=new Random();</span>
		
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">		if(blackBoxStates.size()&gt;0){</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">			for (int i = 0; i &lt; numEncapsulatedStates; i++) {</span>

<span class="fc" id="L258">				State baState = baStatesIterator.next();</span>
<span class="fc" id="L259">				State blackBoxState=blackBoxStates.get(random.nextInt(blackBoxStates.size()));</span>
				
<span class="fc" id="L261">				Replacement replacement = this.blackBoxStateReplacementMap</span>
<span class="fc" id="L262">						.get(blackBoxState);</span>
<span class="fc" id="L263">				replacement.getAutomaton().addState(baState);</span>
<span class="fc" id="L264">				this.blackBoxStateNonEmptyReplacementMap.put(blackBoxState, replacement);</span>
<span class="fc" id="L265">				this.stateReplacementMap.put(baState,</span>
<span class="fc" id="L266">						this.blackBoxStateReplacementMap.get(blackBoxState));</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">				if (this.ba.getInitialStates().contains(baState)) {</span>
<span class="nc" id="L268">					iba.addInitialState(blackBoxState);</span>
<span class="nc" id="L269">					replacement.getAutomaton().addInitialState(baState);</span>
				}
<span class="pc bpc" id="L271" title="1 of 2 branches missed.">				if (this.ba.getAcceptStates().contains(baState)) {</span>
<span class="fc" id="L272">					iba.addAcceptState(blackBoxState);</span>
<span class="fc" id="L273">					replacement.getAutomaton().addAcceptState(baState);</span>
				}
			}
		}
<span class="fc" id="L277">	}</span>

	/**
	 * adds the states to the set of regular states of the IBA
	 * 
	 * @param states
	 *            the regular states to be added to the IBA
	 * @throws NullPointerException
	 *             if the set of the states is null
	 * @throws IllegalArgumentException
	 *             if the set of the state is not included in the states of the
	 *             BA
	 */
	private void addStatesToTheIBA(Set&lt;State&gt; states) {
<span class="fc" id="L291">		Preconditions.checkNotNull(states,</span>
				&quot;The set of the states cannot be null&quot;);
<span class="fc" id="L293">		Preconditions</span>
<span class="fc" id="L294">				.checkArgument(</span>
<span class="fc" id="L295">						this.ba.getStates().containsAll(states),</span>
						&quot;The set of the state to be added must be included into the set of the states of the IBA&quot;);
		// adding the other states to the iba
<span class="fc bfc" id="L298" title="All 2 branches covered.">		for (State state : states) {</span>
<span class="fc" id="L299">			iba.addState(state);</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">			if (this.ba.getInitialStates().contains(state)) {</span>
<span class="fc" id="L301">				iba.addInitialState(state);</span>
			}
<span class="pc bpc" id="L303" title="1 of 2 branches missed.">			if (this.ba.getAcceptStates().contains(state)) {</span>
<span class="nc" id="L304">				iba.addAcceptState(state);</span>
			}
<span class="fc" id="L306">		}</span>
<span class="fc" id="L307">	}</span>

	/**
	 * generates the transitions between the states of the IBA and inside the
	 * replacement
	 */
	private void generateTransitions() {
		// adding the transitions
<span class="fc bfc" id="L315" title="All 2 branches covered.">		for (Transition transition : this.ba.getTransitions()) {</span>
<span class="fc" id="L316">			State source = this.ba.getTransitionSource(transition);</span>
<span class="fc" id="L317">			State destination = this.ba.getTransitionDestination(transition);</span>

<span class="fc bfc" id="L319" title="All 2 branches covered.">			if (stateReplacementMap.containsKey(source)</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">					&amp;&amp; stateReplacementMap.containsKey(destination)) {</span>

<span class="fc" id="L322">				Replacement replacementSource = stateReplacementMap.get(source);</span>
<span class="fc" id="L323">				Replacement replacementDestination = stateReplacementMap</span>
<span class="fc" id="L324">						.get(destination);</span>
<span class="fc" id="L325">				State transparentSource = blackBoxStateReplacementMap</span>
<span class="fc" id="L326">						.inverse().get(replacementSource);</span>
<span class="fc" id="L327">				State transparentDestination = blackBoxStateReplacementMap</span>
<span class="fc" id="L328">						.inverse().get(replacementDestination);</span>

<span class="pc bpc" id="L330" title="1 of 2 branches missed.">				if (replacementSource==replacementDestination) {</span>
<span class="fc" id="L331">					replacementSource.getAutomaton().addTransition(source,</span>
							destination, 
<span class="fc" id="L333">							new ModelTransitionFactory().create(transition.getId(), transition.getPropositions()));</span>
				} else {
<span class="nc" id="L335">					this.iba.addTransition(transparentSource,</span>
<span class="nc" id="L336">							transparentDestination, new ModelTransitionFactory().create(transition.getId(), transition.getPropositions()));</span>
<span class="nc" id="L337">					replacementSource.addOutgoingTransition(new PluggingTransition(transition.getId(),</span>
<span class="nc" id="L338">							source, transparentDestination, new ModelTransitionFactory().create(transition.getId(), transition.getPropositions()), false));</span>
<span class="nc" id="L339">					replacementDestination</span>
<span class="nc" id="L340">							.addIncomingTransition(new PluggingTransition(transition.getId(),</span>
<span class="nc" id="L341">									transparentSource, destination, new ModelTransitionFactory().create(transition.getId(), transition.getPropositions()),</span>
									true));
				}
<span class="fc" id="L344">			} else {</span>
<span class="pc bpc" id="L345" title="1 of 2 branches missed.">				if (stateReplacementMap.containsKey(source)) {</span>
<span class="nc" id="L346">					Replacement replacementSource = stateReplacementMap</span>
<span class="nc" id="L347">							.get(source);</span>
<span class="nc" id="L348">					State blackBoxState = blackBoxStateReplacementMap</span>
<span class="nc" id="L349">							.inverse().get(replacementSource);</span>

<span class="nc" id="L351">					this.iba.addTransition(blackBoxState, destination,</span>
<span class="nc" id="L352">	                         new ModelTransitionFactory().create(transition.getId(), transition.getPropositions()));</span>
<span class="nc" id="L353">					replacementSource.addOutgoingTransition(new PluggingTransition(transition.getId(),</span>
<span class="nc" id="L354">							source, destination, new ModelTransitionFactory().create(transition.getId(), transition.getPropositions()), false));</span>
<span class="nc" id="L355">				} else {</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">					if (stateReplacementMap.containsKey(destination)) {</span>
<span class="fc" id="L357">						Replacement replacementDestination = stateReplacementMap</span>
<span class="fc" id="L358">								.get(destination);</span>
<span class="fc" id="L359">						State transparentDestination = blackBoxStateReplacementMap</span>
<span class="fc" id="L360">								.inverse().get(replacementDestination);</span>

<span class="fc" id="L362">						this.iba.addTransition(source, transparentDestination,</span>
<span class="fc" id="L363">	                            new ModelTransitionFactory().create(transition.getId(), transition.getPropositions()));</span>
<span class="fc" id="L364">						replacementDestination</span>
<span class="fc" id="L365">								.addIncomingTransition(new PluggingTransition(source,</span>
<span class="fc" id="L366">										destination, new ModelTransitionFactory().create(transition.getId(), transition.getPropositions()), true));</span>
<span class="fc" id="L367">					} else {</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">					    if(this.iba.getBlackBoxStates().contains(source)){</span>
<span class="nc" id="L369">					        throw new InternalError(&quot;The source cannot be a black box&quot;);</span>
					    }
<span class="pc bpc" id="L371" title="1 of 2 branches missed.">					    if(this.iba.getBlackBoxStates().contains(destination)){</span>
<span class="nc" id="L372">                            throw new InternalError(&quot;The destination cannot be a black box&quot;);</span>
                            
                        }
<span class="fc" id="L375">						this.iba.addTransition(source, destination, new ModelTransitionFactory().create(transition.getId(), transition.getPropositions()));</span>
					}
				}
			}
<span class="fc" id="L379">		}</span>
<span class="fc" id="L380">	}</span>

	/**
	 * creates the transparent state and the corresponding replacements
	 */
	private void createBlackBoxStatesAndReplacements() {

<span class="fc bfc" id="L387" title="All 2 branches covered.">		for (int i = 0; i &lt; numBlackBoxStates; i++) {</span>
<span class="fc" id="L388">			State blackBoxState = stateFactory.create(&quot;t&quot; + i);</span>
<span class="fc" id="L389">			Replacement rep = new Replacement(blackBoxState, new IBA(</span>
					new ModelTransitionFactory()),
					new HashSet&lt;PluggingTransition&gt;(),
					new HashSet&lt;PluggingTransition&gt;());
<span class="fc" id="L393">			rep.getAutomaton().addPropositions(this.ba.getPropositions());</span>
<span class="fc" id="L394">			this.blackBoxStateReplacementMap.put(blackBoxState, rep);</span>
		}
<span class="fc" id="L396">	}</span>

	/**
	 * returns a Bidirectional map which specifies for each transparent state
	 * the corresponding replacement
	 * 
	 * @return a Bidirectional map which specifies for each transparent state
	 *         the corresponding replacement
	 * @throws IllegalStateException
	 *             if the IBA generation has not been already performed
	 */
	public BiMap&lt;State, Replacement&gt; getTransparentStateReplacementMap() {
<span class="fc" id="L408">		Preconditions</span>
<span class="fc" id="L409">				.checkState(</span>
<span class="fc" id="L410">						this.isPerformed(),</span>
						&quot;The action &quot;
								+ ACTION_NAME
								+ &quot; must be performed before getting the map between transparent states and replacements&quot;);
<span class="fc" id="L414">		return Maps.unmodifiableBiMap(this.blackBoxStateReplacementMap);</span>
	}
	
	/**
	 * returns a Bidirectional map which specifies for each transparent state
	 * the corresponding replacement
	 * 
	 * @return a Bidirectional map which specifies for each transparent state
	 *         the corresponding replacement
	 * @throws IllegalStateException
	 *             if the IBA generation has not been already performed
	 */
	public List&lt;Replacement&gt; getNonEmptyReplacements() {
<span class="nc" id="L427">		Preconditions</span>
<span class="nc" id="L428">				.checkState(</span>
<span class="nc" id="L429">						this.isPerformed(),</span>
						&quot;The action &quot;
								+ ACTION_NAME
								+ &quot; must be performed before getting the map between transparent states and replacements&quot;);
<span class="nc" id="L433">		return new ArrayList&lt;Replacement&gt;(this.blackBoxStateNonEmptyReplacementMap.values());</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>
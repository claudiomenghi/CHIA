<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>IntersectionTransitionBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CHIAChecker</a> &gt; <a href="index.source.html" class="el_package">it.polimi.checker.intersection</a> &gt; <span class="el_source">IntersectionTransitionBuilder.java</span></div><h1>IntersectionTransitionBuilder.java</h1><pre class="source lang-java linenums">package it.polimi.checker.intersection;

import it.polimi.automata.transition.ClaimTransitionFactory;
import it.polimi.automata.transition.PropositionalLogicConstants;
import it.polimi.automata.transition.Transition;

import java.util.Set;

import rwth.i2.ltl2ba4j.model.IGraphProposition;
import rwth.i2.ltl2ba4j.model.impl.GraphProposition;
import rwth.i2.ltl2ba4j.model.impl.SigmaProposition;

import com.google.common.base.Preconditions;

/**
 * Defines an rule that specifies how the transitions of the intersection
 * automaton are generated starting from the transition of the model and the
 * claim. &lt;br&gt;
 * 
 * The rule specifies that the transition of the model can be performed only if
 * it satisfies the conditions specified in the claim. Or, the transition of the
 * claim can be performed if the model is in a black box state
 * 
 * @author Claudio Menghi
 * 
 */
public class IntersectionTransitionBuilder {

	/**
	 * is the factory that allows to create transitions
	 */
	private final ClaimTransitionFactory transitionFactory;

	/**
	 * creates a new Builder that allow to create transitions of the
	 * intersection automaton
	 */
<span class="fc" id="L38">	public IntersectionTransitionBuilder() {</span>
<span class="fc" id="L39">		this.transitionFactory = new ClaimTransitionFactory();</span>
<span class="fc" id="L40">	}</span>

	/**
	 * Given two transitions, one of the model and one of the claim, creates the
	 * intersection transitions. Throws an InternalError if the two transitions
	 * are not compatible, i.e., they cannot be fired together. To check whether
	 * two transitions can be fired together run the is compatible method.
	 * 
	 * @param modelTransition
	 *            the transition of the model to be fired
	 * @param claimTransition
	 *            is the transition of the claim to be fired
	 * @return a transition that is the synchronous execution between the
	 *         modelTransition and the claimTransition
	 * @throws NullPointerException
	 *             if the transition of the model or the claim is null
	 * @throws InternalError
	 *             if the two transitions are not compatible
	 * 
	 */
	public Transition getIntersectionTransition(Transition modelTransition,
			Transition claimTransition) {

<span class="fc" id="L63">		Preconditions.checkNotNull(modelTransition,</span>
				&quot;The model transition cannot be null&quot;);
<span class="fc" id="L65">		Preconditions.checkNotNull(claimTransition,</span>
				&quot;The claim transition cannot be null&quot;);
<span class="fc bfc" id="L67" title="All 2 branches covered.">		if (!this.isCompatible(modelTransition, claimTransition)) {</span>
<span class="fc" id="L68">			throw new InternalError(&quot;The transition of the model:  &quot;</span>
					+ modelTransition + &quot; and the transition of the claim: &quot;
					+ claimTransition + &quot; are not compatible&quot;);
		}
<span class="fc" id="L72">		return transitionFactory.create(modelTransition.getPropositions());</span>

	}

	/**
	 * checks whether the transition of the model and the transition of the
	 * claim are compatible, i.e., it is possible to fire the transition of the
	 * model and the claim synchronously
	 * 
	 * @param modelTransition
	 *            is the transition of the model to be fired
	 * @param claimTransition
	 *            is the transition of the claim to be fired
	 * @return true if the label of the transition of model satisfies the label
	 *         of the transition of the claim
	 *         1) returns true if the stuttering character is contained both on
	 *         the model and the claim label
	 *         2) returns true if the Sigma proposition is
	 *         3) returns false if there is a claim proposition that is
	 *         negated, but the proposition is contained in the labels of the
	 *         model
	 *         4) returns false if there is a claim proposition that is not
	 *         negated, but the proposition is not contained inside the set of
	 *         propositions of the model
	 * 
	 * @throws NullPointerException
	 *             if the transition of the model or the transition of the claim
	 *             is null
	 */
	public boolean isCompatible(Transition modelTransition,
			Transition claimTransition) {
<span class="fc" id="L103">		Preconditions.checkNotNull(</span>
				&quot;The transition of the model cannot be null&quot;, modelTransition);
<span class="fc" id="L105">		Preconditions.checkNotNull(</span>
				&quot;The transition of the claim cannot be null&quot;, claimTransition);
<span class="fc" id="L107">		return this.satisfies(modelTransition.getPropositions(),</span>
<span class="fc" id="L108">				claimTransition.getPropositions());</span>
	}

	/**
	 * returns true if the label of the model satisfies the label of the claim.
	 * 
	 * @param modelLabel
	 *            is the label of the model
	 * @param claimLabel
	 *            is the label of the claim
	 * @return true if the label of the model satisfies the label of the claim
	 *         1) returns true if the stuttering character is contained both on
	 *         the model and the claim label
	 *         2) returns true if the sigma proposition is
	 *         3) returns false if there is a claim proposition that is
	 *         negated, but the proposition is contained in the labels of the
	 *         model
	 *         4) returns false if there is a claim proposition that is not
	 *         negated, but the proposition is not contained inside the set of
	 *         propositions of the model
	 * 
	 */
	protected boolean satisfies(Set&lt;IGraphProposition&gt; modelLabel,
			Set&lt;IGraphProposition&gt; claimLabel) {
<span class="fc" id="L132">		Preconditions</span>
<span class="fc" id="L133">				.checkNotNull(modelLabel, &quot;The model label cannot be null&quot;);</span>
<span class="fc" id="L134">		Preconditions</span>
<span class="fc" id="L135">				.checkNotNull(claimLabel, &quot;The claim label cannot be null&quot;);</span>

<span class="fc" id="L137">		IGraphProposition stuttering = new GraphProposition(</span>
				PropositionalLogicConstants.STUTTERING_CHARACTER, false);
<span class="fc bfc" id="L139" title="All 2 branches covered.">		if (modelLabel.contains(stuttering)) {</span>
<span class="fc" id="L140">			return claimLabel.contains(stuttering);</span>
		}
		// if the proposition is SigmaProposition it is satisfied by the
		// proposition of
		// the model
<span class="fc bfc" id="L145" title="All 2 branches covered.">		if (claimLabel.contains(new SigmaProposition())) {</span>
<span class="fc" id="L146">			return true;</span>
		}
		// for each proposition of the claim
<span class="fc bfc" id="L149" title="All 2 branches covered.">		for (IGraphProposition claimProposition : claimLabel) {</span>

			// if the claim proposition is negated it must not be contained into
			// the set of the proposition of the model
			// e.g. if the proposition is !a a must not be contained into the
			// propositions of the model
			// if the claim contains !a and the model a the condition is not
			// satisfied
<span class="fc bfc" id="L157" title="All 2 branches covered.">			if (claimProposition.isNegated()) {</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">				if (modelLabel.contains(new GraphProposition(claimProposition</span>
<span class="fc" id="L159">						.getLabel(), false))) {</span>
<span class="fc" id="L160">					return false;</span>
				}
			} else {
				// if the claim is not negated it MUST be contained into the
				// propositions of the model
				// if the claim is labeled with a and the model does not contain
				// the proposition a the transition is not satisfied
<span class="fc bfc" id="L167" title="All 2 branches covered.">				if (!modelLabel.contains(new GraphProposition(claimProposition</span>
<span class="fc" id="L168">						.getLabel(), false))) {</span>
<span class="fc" id="L169">					return false;</span>
				}
			}
<span class="fc" id="L172">		}</span>
<span class="fc" id="L173">		return true;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StatePresencePathChecker.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CHIAContraintComputation</a> &gt; <a href="index.source.html" class="el_package">it.polimi.constraintcomputation.reachability.statepresence</a> &gt; <span class="el_source">StatePresencePathChecker.java</span></div><h1>StatePresencePathChecker.java</h1><pre class="source lang-java linenums">package it.polimi.constraintcomputation.reachability.statepresence;

import it.polimi.automata.BA;
import it.polimi.automata.state.State;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import com.google.common.base.Preconditions;

/**
 * Computes the states that are backward and forward reachable from the set of
 * interesting states &lt;br&gt;
 * 
 * Checks if the destination is reachable from the source and at least an
 * interesting state is traversed along the search
 * 
 * @author Claudio Menghi
 *
 */
public class StatePresencePathChecker {

	/**
	 * the Buchi automaton to be considered
	 */
	private final BA ba;

	/**
	 * the set of the states that can be traversed during the reachability
	 * search
	 */
	private final Set&lt;State&gt; states;

	/**
	 * the set of the states that are of interest
	 */
	private final Set&lt;State&gt; intersetingStates;

	/**
	 * specifies that from the first state of the entry it is possible to reach
	 * the second state of the entry by crossing at least an interesting state
	 */
	private final Map&lt;State, Set&lt;State&gt;&gt; reachable;

	/**
	 * specifies if the search has been performed
	 */
	private boolean performed;

	/**
	 * &lt;p&gt;
	 * creates a new checker that aims to detect whether there exists a path
	 * from the source to the destination that contains an accepting state.
	 * &lt;/p&gt;
	 * 
	 * THE SET OF THE INTERESTING STATES MUST BE INCLUDED INTO THE SET OF THE
	 * STATES THAT CAN BE TRAVERSED
	 * 
	 * @param ba
	 *            the BA under analysis
	 * @param states
	 *            the set of the states that can be traversed in the
	 *            reachability search
	 * @param intersetingStates
	 *            is the set of the states of interest
	 * @throws NullPointerException
	 *             if the BA under analysis or one of the two sets is null
	 * @throws IllegalArgumentException
	 *             if the one of the two sets has a state that is not contained
	 *             into the set of the states of the BA
	 * @throws IllegalArgumentException
	 *             if the set of interesting states is not included into the set
	 *             of the states that can be traversed
	 * 
	 */
	public StatePresencePathChecker(BA ba, Set&lt;State&gt; states,
<span class="fc" id="L79">			Set&lt;State&gt; intersetingStates) {</span>
<span class="fc" id="L80">		Preconditions.checkNotNull(ba, &quot;The BA under analysis cannot be null&quot;);</span>
<span class="fc" id="L81">		Preconditions.checkNotNull(states,</span>
				&quot;The set of the states under analysis cannot be null&quot;);
<span class="fc" id="L83">		Preconditions.checkNotNull(intersetingStates,</span>
				&quot;The set of the interesting states cannot be null&quot;);

<span class="fc" id="L86">		Preconditions</span>
<span class="fc" id="L87">				.checkArgument(</span>
<span class="fc" id="L88">						ba.getStates().containsAll(states),</span>
						&quot;The set of the states to be traversed must be contained into the set of the states of the automaton&quot;);

<span class="fc" id="L91">		Preconditions</span>
<span class="fc" id="L92">				.checkArgument(</span>
<span class="fc" id="L93">						ba.getStates().containsAll(intersetingStates),</span>
						&quot;the set of interesting states must be contained into the set of the states of the automaton&quot;);

<span class="fc" id="L96">		Preconditions</span>
<span class="fc" id="L97">				.checkArgument(</span>
<span class="fc" id="L98">						states.containsAll(intersetingStates),</span>
						&quot;The set of interesting states is not included into the set of the states that can be traversed&quot;);
<span class="fc" id="L100">		this.ba = ba;</span>
<span class="fc" id="L101">		this.states = new HashSet&lt;State&gt;(states);</span>
<span class="fc" id="L102">		this.intersetingStates = new HashSet&lt;State&gt;(intersetingStates);</span>

<span class="fc" id="L104">		this.reachable = new HashMap&lt;State, Set&lt;State&gt;&gt;();</span>
<span class="fc" id="L105">		this.performed = false;</span>
		// creates for each of the intersting state an entry in the backward and
		// in the forward map

<span class="fc" id="L109">	}</span>

	/**
	 * checks if the destination is reachable from the source and at least an
	 * interesting state is traversed along the search
	 * 
	 * @param source
	 *            is the source state of interest
	 * @param destination
	 *            is the destination state of interest
	 * @return true if the destination is reachable from the source and at least
	 *         an interesting state is traversed along the search
	 * @throws IllegalStateException
	 *             if the search has not been performed before invoking this
	 *             method
	 * @throws NullPointerException
	 *             if the source or the destination is null
	 * @throws IllegalArgumentException
	 *             if the source or the destination is not in the states of the
	 *             BA
	 * @throws IllegalArgumentException
	 *             if the source or the destination is not included into the set
	 *             of the states of interest
	 */
	public boolean isReachableByPassingAnInterestingState(State source,
			State destination) {
<span class="fc" id="L135">		Preconditions.checkState(performed,</span>
				&quot;Checks if the search has been performed&quot;);
<span class="fc" id="L137">		Preconditions.checkNotNull(source, &quot;The source state cannot be null&quot;);</span>
<span class="fc" id="L138">		Preconditions.checkNotNull(destination,</span>
				&quot;The destination state cannot be null&quot;);
<span class="fc" id="L140">		Preconditions.checkArgument(this.ba.getStates().contains(source),</span>
				&quot;The source state must be a state of the BA&quot;);
<span class="fc" id="L142">		Preconditions.checkArgument(this.ba.getStates().contains(destination),</span>
				&quot;The destination state must be a state of the BA&quot;);
<span class="fc" id="L144">		Preconditions</span>
<span class="fc" id="L145">				.checkArgument(</span>
<span class="fc" id="L146">						this.states.contains(source),</span>
						&quot;The source state must be contained into the set of the states that can be traversed&quot;);
<span class="fc" id="L148">		Preconditions</span>
<span class="fc" id="L149">				.checkArgument(</span>
<span class="fc" id="L150">						this.states.contains(destination),</span>
						&quot;The destination state must be contained into the set of the states that can be traversed&quot;);

<span class="fc bfc" id="L153" title="All 2 branches covered.">		if (!this.reachable.containsKey(source)) {</span>
<span class="fc" id="L154">			return false;</span>

		}
<span class="fc" id="L157">		return this.reachable.get(source).contains(destination);</span>
	}

	/**
	 * computes whether there exists a path from every possible source to
	 * destination state that contains at least a state of interest
	 * 
	 * @param interestingSourceStates
	 *            the source states of interest
	 * @param interestingDestinationStates
	 *            the destination states of interest
	 */
	public void perform(Set&lt;State&gt; interestingSourceStates,
			Set&lt;State&gt; interestingDestinationStates) {

		// for each state of interest computes the backward and the forward
		// reachable states
<span class="fc bfc" id="L174" title="All 2 branches covered.">		for (State interestingState : this.intersetingStates) {</span>
<span class="fc" id="L175">			Set&lt;State&gt; backwardStates = backwardCheck(interestingState);</span>
<span class="fc" id="L176">			Set&lt;State&gt; forwardReachableStates = forwardCheck(interestingState);</span>
<span class="fc" id="L177">			this.findConnectedStates(backwardStates, forwardReachableStates,</span>
					interestingSourceStates, interestingDestinationStates);
<span class="fc" id="L179">			forwardReachableStates.clear();</span>
<span class="fc" id="L180">			backwardStates.clear();</span>

<span class="fc" id="L182">		}</span>

<span class="fc" id="L184">		this.intersetingStates.clear();</span>
<span class="fc" id="L185">		this.performed = true;</span>
<span class="fc" id="L186">	}</span>

	/**
	 * Finds the source and the destination state that are connected with a path
	 * that crosses the interesting state
	 * 
	 * @param backwardStates
	 *            the set of backward reachable states
	 * @param forwardStates
	 *            the set of forward reachable states
	 * @param interestingSourceStates
	 *            the set of source states of interest
	 * @param interestingDestinationStates
	 *            the set of destination states of interest
	 */
	private void findConnectedStates(Set&lt;State&gt; backwardStates,
			Set&lt;State&gt; forwardStates, Set&lt;State&gt; interestingSourceStates,
			Set&lt;State&gt; interestingDestinationStates) {
<span class="fc" id="L204">		backwardStates.retainAll(interestingSourceStates);</span>
<span class="fc" id="L205">		forwardStates.retainAll(interestingDestinationStates);</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">		for (State sourceState : backwardStates) {</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">			if (this.reachable.containsKey(sourceState)) {</span>
<span class="fc" id="L208">				this.reachable.get(sourceState).addAll(forwardStates);</span>
			} else {
<span class="fc" id="L210">				this.reachable.put(sourceState, new HashSet&lt;State&gt;(</span>
						forwardStates));
			}
<span class="fc" id="L213">		}</span>
<span class="fc" id="L214">	}</span>

	/**
	 * returns the states that are backward reachable from the specified state
	 * (including the state itself)
	 * 
	 * @param state
	 *            the state to be considered
	 * @return the states that are backward reachable from the specified state
	 * @throws NullPointerException
	 *             if the specified state is null
	 */
	private Set&lt;State&gt; backwardCheck(State state) {

<span class="fc" id="L228">		Set&lt;State&gt; backwardStates = new HashSet&lt;State&gt;(</span>
<span class="fc" id="L229">				this.intersetingStates.size());</span>

<span class="fc" id="L231">		backwardStates.add(state);</span>
		// the set of the states to be analyzed next
<span class="fc" id="L233">		Set&lt;State&gt; nextStates = new HashSet&lt;State&gt;();</span>
<span class="fc" id="L234">		nextStates.add(state);</span>
<span class="fc" id="L235">		Set&lt;State&gt; visitedStates = new HashSet&lt;State&gt;();</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">		while (!nextStates.isEmpty()) {</span>
<span class="fc" id="L237">			State next = nextStates.iterator().next();</span>
<span class="fc" id="L238">			nextStates.remove(next);</span>
<span class="fc" id="L239">			visitedStates.add(next);</span>
<span class="fc bfc" id="L240" title="All 2 branches covered.">			for (State predecessor : this.ba.getPredecessors(next)) {</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">				if (this.states.contains(predecessor)</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">						&amp;&amp; !visitedStates.contains(predecessor)) {</span>
<span class="fc" id="L243">					backwardStates.add(predecessor);</span>
<span class="fc" id="L244">					nextStates.add(predecessor);</span>
				}
<span class="fc" id="L246">			}</span>
<span class="fc" id="L247">		}</span>
<span class="fc" id="L248">		return backwardStates;</span>
	}

	/**
	 * returns the states that are forward reachable from the specified state
	 * (including the state itself)
	 * 
	 * @param state
	 *            the state to be considered
	 * @return the states that are forward reachable from the specified state
	 * @throws NullPointerException
	 *             if the specified state is null
	 */
	private Set&lt;State&gt; forwardCheck(State state) {

<span class="fc" id="L263">		Set&lt;State&gt; forwardStates = new HashSet&lt;State&gt;(</span>
<span class="fc" id="L264">				this.intersetingStates.size());</span>
<span class="fc" id="L265">		forwardStates.add(state);</span>
<span class="fc" id="L266">		Set&lt;State&gt; nextStates = new HashSet&lt;State&gt;();</span>
<span class="fc" id="L267">		nextStates.add(state);</span>
<span class="fc" id="L268">		Set&lt;State&gt; visitedStates = new HashSet&lt;State&gt;();</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">		while (!nextStates.isEmpty()) {</span>
<span class="fc" id="L270">			State next = nextStates.iterator().next();</span>
<span class="fc" id="L271">			nextStates.remove(next);</span>
<span class="fc" id="L272">			visitedStates.add(next);</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">			for (State successorState : this.ba.getSuccessors(next)) {</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">				if (this.states.contains(successorState)</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">						&amp;&amp; !visitedStates.contains(successorState)) {</span>
<span class="fc" id="L276">					forwardStates.add(successorState);</span>
<span class="fc" id="L277">					nextStates.add(successorState);</span>
				}
<span class="fc" id="L279">			}</span>
<span class="fc" id="L280">		}</span>
<span class="fc" id="L281">		return forwardStates;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BackwardLabeler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CHIAContraintComputation</a> &gt; <a href="index.source.html" class="el_package">it.polimi.constraintcomputation.subpropertyidentifier.labeling</a> &gt; <span class="el_source">BackwardLabeler.java</span></div><h1>BackwardLabeler.java</h1><pre class="source lang-java linenums">package it.polimi.constraintcomputation.subpropertyidentifier.labeling;

import it.polimi.automata.IntersectionBA;
import it.polimi.automata.state.State;
import it.polimi.automata.transition.Transition;
import it.polimi.constraintcomputation.subpropertyidentifier.SubPropertyIdentifier;
import it.polimi.constraints.transitions.Label;

import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.jgrapht.alg.StrongConnectivityInspector;

import com.google.common.base.Preconditions;

/**
 * &lt;p&gt;
 * it is used to label with the specified label all the outgoing transitions of
 * a sub-property 
 * &lt;/p&gt;
 * 
 * It modifies the sub-property contained in the {@link SubPropertyIdentifier}
 * passed as parameter
 * 
 * @author Claudio Menghi
 *
 */
public class BackwardLabeler {

    /**
     * contains the intersection automaton to be considered in the labeling
     */
    private final IntersectionBA intersectionAutomaton;

    /**
     * contains the set of the states to be considered in the automaton
     * exploration
     */
    private final Set&lt;State&gt; states;

    /**
     * contains the label the developer wants to associate to the outgoing
     * transitions of the sub-property
     */
    private final Label label;

    /**
     * is the identifier which has been used to generate the sub-property of
     * interest
     */
    private final SubPropertyIdentifier subPropertyIntifier;

    /**
     * contains the set of the visited states. It is used to has the already
     * visited states to guarantee that a state is not visited twice
     */
    private final Set&lt;State&gt; visitedStates;

    /**
     * creates a new Backward labeler function. This function is used to mark
     * with the specified label all the outgoing transitions of the sub-property
     * 
     * @param states
     *            is the set of the states of the intersection automaton to be
     *            considered
     * @param label
     *            is the label to be associated with the outgoing transitions
     * @param subProperty
     *            is the sub-property to be considered by the
     *            {@link BackwardLabeler}
     * @throws NullPointerException
     *             if one of the parameters is null
     * @throws IllegalArgumentException
     *             if the set of the states to be considered is not included in
     *             the set of the states of the automaton
     */
    public BackwardLabeler(Set&lt;State&gt; states, Label label,
<span class="fc" id="L80">            SubPropertyIdentifier subProperty) {</span>
<span class="fc" id="L81">        Preconditions.checkNotNull(states,</span>
                &quot;The set of the states to be considered cannot be null&quot;);
<span class="fc" id="L83">        Preconditions.checkNotNull(label,</span>
                &quot;The color to be considered cannot be null&quot;);
<span class="fc" id="L85">        Preconditions</span>
<span class="fc" id="L86">                .checkArgument(</span>
<span class="fc" id="L87">                        subProperty.getChecker().getUpperIntersectionBA()</span>
<span class="fc" id="L88">                                .getStates().containsAll(states),</span>
                        &quot;All the states to be considered must be contained into the set of the states of the automaton&quot;);

<span class="fc" id="L91">        this.intersectionAutomaton = subProperty.getChecker()</span>
<span class="fc" id="L92">                .getUpperIntersectionBA();</span>
<span class="fc" id="L93">        this.states = states;</span>
<span class="fc" id="L94">        this.label = label;</span>
<span class="fc" id="L95">        this.subPropertyIntifier = subProperty;</span>
<span class="fc" id="L96">        this.visitedStates = new HashSet&lt;State&gt;();</span>
<span class="fc" id="L97">    }</span>

    /**
     * &lt;p&gt;
     * modifies the outgoing transitions of the sub-property with the following
     * policy: 
     * &lt;/p&gt;
     * 
     * if the outgoing transition allows to reach a SSC that contains an
     * accepting state that can be entered infinitely often, the outgoing
     * transition is marked with the label specified as parameter
     * 
     */
    public void perform() {
        // constructs an abstracted version of the intersection automaton that
        // contains only the specified states
<span class="fc" id="L113">        IntersectionBA abstractedIntersectionAutomaton = this.intersectionAutomaton</span>
<span class="fc" id="L114">                .getAbstraction(this.states);</span>

        // finds the strongly connected components of the intersection automaton
<span class="fc" id="L117">        StrongConnectivityInspector&lt;State, Transition&gt; connectivityInspector = new StrongConnectivityInspector&lt;State, Transition&gt;(</span>
<span class="fc" id="L118">                abstractedIntersectionAutomaton.getGraph());</span>
<span class="fc" id="L119">        List&lt;Set&lt;State&gt;&gt; connectedSets = connectivityInspector</span>
<span class="fc" id="L120">                .stronglyConnectedSets();</span>

<span class="fc" id="L122">        Set&lt;State&gt; next = new HashSet&lt;State&gt;();</span>
        // for each strongly connected component
<span class="fc bfc" id="L124" title="All 2 branches covered.">        for (Set&lt;State&gt; scc : connectedSets) {</span>
            // if at least an accepting state is contained, its states are added
            // to the set next to be visited next
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">            if(states.containsAll(scc)){</span>
<span class="fc bfc" id="L128" title="All 2 branches covered.">                if (!Collections.disjoint(scc,</span>
<span class="fc" id="L129">                        abstractedIntersectionAutomaton.getAcceptStates())) {</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">                    if(scc.size()&gt;1){</span>
<span class="fc" id="L131">                        next.addAll(scc);</span>
                    }
                    else{
<span class="fc" id="L134">                        State state=scc.iterator().next();</span>
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">                        if(abstractedIntersectionAutomaton.isSuccessor(state, state)){</span>
<span class="nc" id="L136">                            next.add(state);</span>
                        }
                    }
                }    
            }
<span class="fc" id="L141">        }</span>

        // while the set of the states to be visited next is not empty
<span class="fc bfc" id="L144" title="All 2 branches covered.">        while (!next.isEmpty()) {</span>
            // pick a state, add the state to the set of visited states
<span class="fc" id="L146">            State s = next.iterator().next();</span>
<span class="fc" id="L147">            visitedStates.add(s);</span>
            // removes the state from the set next
<span class="fc" id="L149">            next.remove(s);</span>
            // analyzes an incoming transition
<span class="fc bfc" id="L151" title="All 2 branches covered.">            for (Transition incomingTransition : intersectionAutomaton</span>
<span class="fc" id="L152">                    .getInTransitions(s)) {</span>
<span class="fc" id="L153">                State source = intersectionAutomaton</span>
<span class="fc" id="L154">                        .getTransitionSource(incomingTransition);</span>
                // if the source is a state of the automaton that corresponds to
                // the sub-property
<span class="fc" id="L157">                if (this.subPropertyIntifier.perform().getAutomaton()</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">                        .getStates().contains(source)) {</span>
                    // the transition is an incoming transition and must be
                    // labeled
<span class="fc" id="L161">                    label(incomingTransition);</span>
                } else {
                    // if the state can be traversed and has not been visited it
                    // is added to the set of the states to be visited next
<span class="fc bfc" id="L165" title="All 2 branches covered.">                    if (!visitedStates.contains(source)) {</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">                        if (this.states.contains(source)) {</span>
<span class="fc" id="L167">                            next.add(source);</span>
                        }
                    }
                }
<span class="fc" id="L171">            }</span>
<span class="fc" id="L172">        }</span>
<span class="fc" id="L173">    }</span>

    /**
     * performs the labeling action over the outgoing transition
     * 
     * @param outgoingTransition
     *            the outgoing transition to be labeled
     */
    private void label(Transition outgoingTransition) {
        // if the outgoing transition is not labeled as R
<span class="fc" id="L183">        if (!(this.subPropertyIntifier</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">                .getOutgoingTransition(outgoingTransition).getLabel() == Label.R)) {</span>

            // modifies the number of yellow outgoing transitions
<span class="fc bfc" id="L187" title="All 2 branches covered.">            if (label.equals(Label.Y)) {</span>
<span class="fc" id="L188">                this.subPropertyIntifier.perform()</span>
<span class="fc" id="L189">                        .incrementNumberYellowOutgoingTransitions();</span>
            }
            // modifies the number of red outgoing transitions
<span class="fc bfc" id="L192" title="All 2 branches covered.">            if (label.equals(Label.R)) {</span>
<span class="fc" id="L193">                this.subPropertyIntifier.perform()</span>
<span class="fc" id="L194">                        .incrementNumberRedOutgoingTransitions();</span>
            }
            // performs the actual labeling
<span class="fc" id="L197">            this.subPropertyIntifier.getOutgoingTransition(outgoingTransition)</span>
<span class="fc" id="L198">                    .setLabel(label);</span>
        }
<span class="fc" id="L200">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>
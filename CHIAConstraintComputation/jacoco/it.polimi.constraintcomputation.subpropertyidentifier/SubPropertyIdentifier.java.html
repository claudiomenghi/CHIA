<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SubPropertyIdentifier.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CHIAContraintComputation</a> &gt; <a href="index.source.html" class="el_package">it.polimi.constraintcomputation.subpropertyidentifier</a> &gt; <span class="el_source">SubPropertyIdentifier.java</span></div><h1>SubPropertyIdentifier.java</h1><pre class="source lang-java linenums">package it.polimi.constraintcomputation.subpropertyidentifier;

import it.polimi.action.CHIAAction;
import it.polimi.automata.BA;
import it.polimi.automata.state.State;
import it.polimi.automata.transition.ClaimTransitionFactory;
import it.polimi.automata.transition.PropositionalLogicConstants;
import it.polimi.automata.transition.Transition;
import it.polimi.checker.Checker;
import it.polimi.constraints.components.SubProperty;
import it.polimi.constraints.transitions.Label;
import it.polimi.constraints.transitions.LabeledPluggingTransition;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import rwth.i2.ltl2ba4j.model.IGraphProposition;
import rwth.i2.ltl2ba4j.model.impl.GraphProposition;

import com.google.common.base.Preconditions;

/**
 * This class identifies the sub-automata of the automaton that refer to the
 * &lt;b&gt;black box&lt;/b&gt; states of the original model. In particular it isolates the
 * portions of the state space that refer to the black box states of the model
 * into components. &lt;br&gt;
 * 
 * Each component includes the refinements of the black box states that make the
 * intersection not empty
 *
 * @author claudiomenghi
 * 
 */
public class SubPropertyIdentifier extends CHIAAction&lt;SubProperty&gt; {

    private final Set&lt;IGraphProposition&gt; stutteringPropositions;

    /**
     * contains the subProperty that refers to the black box state
     */
    private final SubProperty subProperty;

    /**
     * is the checker which has been used to check the model against the
     * corresponding claim
     */
    private final Checker checker;

    /**
     * the black box state that is considered
     */
    private final State blackBoxState;

    /**
     * The incoming transitions are the transitions that enters the current
     * refinement level: they can be initial transition, i.e., transitions that
     * arrives from the outside or transition that reaches the current level
     * from the refinement of a black box state
     */
    private final Map&lt;Transition, LabeledPluggingTransition&gt; mapIntersectionTransitionOutgoingTransition;

    /**
     * The out-coming transitions are the transition that leave the current
     * refinement level: they can be final transition, i.e., transitions that
     * leaves the current refinement level to an ``upper level&quot; component or
     * transitions that enter the black box state
     */
    private final Map&lt;Transition, LabeledPluggingTransition&gt; mapIntersectionTransitionIncomingTransition;

    /**
     * creates an identifier that is used to isolate the sub-property that
     * refers to the blackBoxState
     * 
     * @param checker
     *            is the checker that has been used to check the model and the
     *            claim
     * @param blackBoxState
     *            is the black box state of interest
     * @throws NullPointerException
     *             if the checker is null or the blackBoxState is null
     * @throws IllegalArgumentException
     *             the blackBoxState must be a black box state of the model
     * @throws IllegalStateException
     *             the checking activity must be performed before the
     *             sub-property identification
     * 
     */
    public SubPropertyIdentifier(Checker checker, State blackBoxState) {

<span class="fc" id="L93">        super(&quot;SUB-PROPERTY identifier&quot;);</span>
<span class="fc" id="L94">        Preconditions.checkNotNull(checker, &quot;The checker cannot be null&quot;);</span>
<span class="fc" id="L95">        Preconditions.checkNotNull(blackBoxState,</span>
                &quot;The black box state to be considered cannot be null&quot;);

<span class="fc" id="L98">        Preconditions</span>
<span class="fc" id="L99">                .checkState(</span>
<span class="fc" id="L100">                        checker.isPerformed(),</span>
                        &quot;The checking activity must be performed before the computation of the sub-property&quot;);
<span class="fc" id="L102">        Preconditions</span>
<span class="fc" id="L103">                .checkArgument(checker.getUpperIntersectionBuilder().getModel()</span>
<span class="fc" id="L104">                        .getBlackBoxStates().contains(blackBoxState),</span>
                        &quot;The state to be considered must be a black box state of the model&quot;);

<span class="fc" id="L107">        this.blackBoxState = blackBoxState;</span>
<span class="fc" id="L108">        this.checker = checker;</span>

<span class="fc" id="L110">        this.subProperty = new SubProperty(blackBoxState, new BA(</span>
                new ClaimTransitionFactory()));

<span class="fc" id="L113">        this.mapIntersectionTransitionOutgoingTransition = new HashMap&lt;Transition, LabeledPluggingTransition&gt;();</span>
<span class="fc" id="L114">        this.mapIntersectionTransitionIncomingTransition = new HashMap&lt;Transition, LabeledPluggingTransition&gt;();</span>
<span class="fc" id="L115">        this.stutteringPropositions = new HashSet&lt;IGraphProposition&gt;();</span>
<span class="fc" id="L116">        this.stutteringPropositions.add(new GraphProposition(</span>
                PropositionalLogicConstants.STUTTERING_CHARACTER, false));

<span class="fc" id="L119">    }</span>

    /**
     * returns an abstracted version of the intersection automaton, where each
     * state is a component and represents a state of the original model and
     * aggregates the states of the intersection automaton which refer to the
     * same black box state
     * 
     * @return the sub-automata of the automaton that refer to the black box
     *         states of M.
     */
    @Override
    public SubProperty perform() {

<span class="fc bfc" id="L133" title="All 2 branches covered.">        if (this.isPerformed()) {</span>
<span class="fc" id="L134">            return this.subProperty;</span>
        }

        // adds the propositions to the set of the propositions of the automaton
        // associated with the sub-Property
<span class="fc" id="L139">        this.addPropositions();</span>
        // creates the states associated with the sub-property
<span class="fc" id="L141">        this.createStates();</span>
        // creates the internal transitions and the incoming and outgoing
        // transitions
<span class="fc" id="L144">        this.createTransitions();</span>

<span class="fc" id="L146">        this.performed();</span>
<span class="fc" id="L147">        return this.subProperty;</span>
    }

    /**
     * creates the transitions inside the current refinement
     */
    private void createTransitions() {
<span class="fc" id="L154">        this.createInternalTransitions();</span>
<span class="fc" id="L155">        this.createIncomingTransitions();</span>
<span class="fc" id="L156">        this.createOutgoingTransitions();</span>
<span class="fc" id="L157">    }</span>

    /**
     * adds the propositions associated to the claim to the set of propositions
     * of the automaton associated with the sub-property
     */
    private void addPropositions() {
        /*
         * creates a component which correspond with the state modelState
         */
<span class="fc" id="L167">        this.subProperty.getAutomaton().addPropositions(</span>
<span class="fc" id="L168">                this.checker.getUpperIntersectionBuilder().getClaim()</span>
<span class="fc" id="L169">                        .getPropositions());</span>

<span class="fc" id="L171">    }</span>

    /**
     * creates the states of the automaton associated with the sub-property
     */
    private void createStates() {

        /*
         * gets the intersectionState associated with the state of the model
         * modelState
         */
<span class="fc bfc" id="L182" title="All 2 branches covered.">        for (State intersectionState : this.checker</span>
<span class="fc" id="L183">                .getUpperIntersectionBuilder().getModelIntersectionStates(</span>
                        this.blackBoxState)) {
<span class="fc" id="L185">            this.subProperty.getAutomaton().addState(intersectionState);</span>
<span class="fc" id="L186">            if (this.checker.getUpperIntersectionBuilder()</span>
<span class="fc" id="L187">                    .getIntersectionAutomaton().getInitialStates()</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">                    .contains(intersectionState)) {</span>
                // add the component to the initial states of the
                // abstracted
                // automaton
<span class="fc" id="L192">                this.subProperty.getAutomaton().addInitialState(</span>
                        intersectionState);
            }
<span class="fc" id="L195">            if (this.checker.getUpperIntersectionBuilder()</span>
<span class="fc" id="L196">                    .getIntersectionAutomaton().getAcceptStates()</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">                    .contains(intersectionState)) {</span>
                // add the component to the accepting states of the
                // abstracted automaton
<span class="fc" id="L200">                this.subProperty.getAutomaton().addAcceptState(</span>
                        intersectionState);
            }
<span class="fc" id="L203">        }</span>
<span class="fc" id="L204">    }</span>

    /**
     * creates the transitions to be inserted into the automaton that refines
     * the sub-property. These transitions include all the transitions that are
     * associated to a black box state of the model
     */
    private void createInternalTransitions() {
<span class="fc bfc" id="L212" title="All 2 branches covered.">        for (Transition internalTransition : this.checker</span>
<span class="fc" id="L213">                .getUpperIntersectionBuilder().getConstrainedTransitions(</span>
                        this.blackBoxState)) {

<span class="fc" id="L216">            Transition newTransition = new ClaimTransitionFactory().create(</span>
<span class="fc" id="L217">                    internalTransition.getId(),</span>
<span class="fc" id="L218">                    internalTransition.getPropositions());</span>
<span class="fc" id="L219">            State sourceState = this.checker.getUpperIntersectionBuilder()</span>
<span class="fc" id="L220">                    .getIntersectionAutomaton()</span>
<span class="fc" id="L221">                    .getTransitionSource(internalTransition);</span>
<span class="fc" id="L222">            State destinationState = this.checker.getUpperIntersectionBuilder()</span>
<span class="fc" id="L223">                    .getIntersectionAutomaton()</span>
<span class="fc" id="L224">                    .getTransitionDestination(internalTransition);</span>
<span class="fc" id="L225">            this.subProperty.getAutomaton().addTransition(sourceState,</span>
                    destinationState, newTransition);

<span class="fc" id="L228">        }</span>
<span class="fc" id="L229">    }</span>

    /**
     * creates the incoming transitions associated with the sub-property
     */
    private void createIncomingTransitions() {
<span class="fc bfc" id="L235" title="All 2 branches covered.">        for (State intersectionState : this.checker</span>
<span class="fc" id="L236">                .getUpperIntersectionBuilder().getModelIntersectionStates(</span>
                        this.blackBoxState)) {

            /*
             * first the algorithm searches for out-coming transition. The
             * transition that reaches an intersection state associated with a
             * black box state of the model are POTENTIAL out-coming transitions
             * since they leaves the current level of refinement, i.e., they
             * enter the refinement of the black box state
             */
<span class="fc bfc" id="L246" title="All 2 branches covered.">            for (Transition incomingTransition : this.checker</span>
<span class="fc" id="L247">                    .getUpperIntersectionBuilder().getIntersectionAutomaton()</span>
<span class="fc" id="L248">                    .getInTransitions(intersectionState)) {</span>

<span class="fc" id="L250">                if (!this.checker.getUpperIntersectionBuilder()</span>
<span class="fc" id="L251">                        .getConstrainedTransitions(this.blackBoxState)</span>
<span class="fc bfc" id="L252" title="All 2 branches covered.">                        .contains(incomingTransition)) {</span>
<span class="fc" id="L253">                    State sourceIntersectionState = this.checker</span>
<span class="fc" id="L254">                            .getUpperIntersectionBuilder()</span>
<span class="fc" id="L255">                            .getIntersectionAutomaton()</span>
<span class="fc" id="L256">                            .getTransitionSource(incomingTransition);</span>

<span class="fc" id="L258">                    if (!this.checker.getUpperIntersectionBuilder()</span>
<span class="fc" id="L259">                            .getModelState(sourceIntersectionState)</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">                            .equals(blackBoxState)) {</span>

                        /*
                         * the destination is an intersection state since I left
                         * the current level of refinement to go to the
                         * refinement, i.e., the intersection
                         */
<span class="fc" id="L267">                        LabeledPluggingTransition incomingPort = new LabeledPluggingTransition(</span>
<span class="fc" id="L268">                                this.checker.getUpperIntersectionBuilder()</span>
<span class="fc" id="L269">                                        .getModelState(sourceIntersectionState),</span>
                                intersectionState, incomingTransition, true,
                                Label.B);

<span class="fc" id="L273">                        this.mapIntersectionTransitionIncomingTransition.put(</span>
                                incomingTransition, incomingPort);
                        /*
                         * the port outcomingPort is out-coming for the current
                         * level of refinement but is an incoming port with
                         * respect to the intersectionStateComponent
                         */
<span class="fc" id="L280">                        this.subProperty.addIncomingTransition(incomingPort);</span>

                    }
                }
<span class="fc" id="L284">            }</span>
<span class="fc" id="L285">        }</span>
<span class="fc" id="L286">    }</span>

    /**
     * creates the outgoing transition associated with the sub-property
     */
    private void createOutgoingTransitions() {

<span class="fc bfc" id="L293" title="All 2 branches covered.">        for (State intersectionState : this.checker</span>
<span class="fc" id="L294">                .getUpperIntersectionBuilder().getModelIntersectionStates(</span>
                        this.blackBoxState)) {
            /*
             * The transitions that exit a mixed state are potential incoming
             * transitions since they are potential transitions that moves from
             * the refinement of the black box state to the current level of
             * abstraction
             */
<span class="fc bfc" id="L302" title="All 2 branches covered.">            for (Transition outgoingTransition : this.checker</span>
<span class="fc" id="L303">                    .getUpperIntersectionBuilder().getIntersectionAutomaton()</span>
<span class="fc" id="L304">                    .getOutTransitions(intersectionState)) {</span>
<span class="fc" id="L305">                if (!this.checker.getUpperIntersectionBuilder()</span>
<span class="fc" id="L306">                        .getIntersectionAutomaton().getConstrainedTransitions()</span>
<span class="fc bfc" id="L307" title="All 2 branches covered.">                        .contains(outgoingTransition)) {</span>
<span class="fc" id="L308">                    State destinationIntersectionState = this.checker</span>
<span class="fc" id="L309">                            .getUpperIntersectionBuilder()</span>
<span class="fc" id="L310">                            .getIntersectionAutomaton()</span>
<span class="fc" id="L311">                            .getTransitionDestination(outgoingTransition);</span>

                    /*
                     * the source state is an intersection state since I leaved
                     * the previous level of the refinement to go to the current
                     * one (exit the black box)
                     */
<span class="fc" id="L318">                    LabeledPluggingTransition labeledOutgoingTransition = new LabeledPluggingTransition(</span>
                            intersectionState,
                            this.checker
<span class="fc" id="L321">                                    .getUpperIntersectionBuilder()</span>
<span class="fc" id="L322">                                    .getModelState(destinationIntersectionState),</span>
                            outgoingTransition, false, Label.B);

<span class="fc" id="L325">                    this.mapIntersectionTransitionOutgoingTransition.put(</span>
                            outgoingTransition, labeledOutgoingTransition);

<span class="fc" id="L328">                    this.subProperty</span>
<span class="fc" id="L329">                            .addOutgoingTransition(labeledOutgoingTransition);</span>

                }
<span class="fc" id="L332">            }</span>
<span class="fc" id="L333">        }</span>
<span class="fc" id="L334">    }</span>

    /**
     * returns true if the intersection transition T is associated with an
     * incoming transition
     * 
     * @param intersectionTransition
     *            is the transition of the intersection automaton
     * @return true if the transition of the intersection automaton is
     *         associated with a incoming transition
     * @throws NullPointerException
     *             if the transition t is null
     * @throws IllegalStateException
     *             if the subproperty identifier has not been performed
     */
    public boolean isInTransition(Transition intersectionTransition) {
<span class="fc" id="L350">        Preconditions</span>
<span class="fc" id="L351">                .checkState(this.isPerformed(),</span>
                        &quot;You must compute the subproperties before performing this operation&quot;);
<span class="fc" id="L353">        Preconditions.checkNotNull(intersectionTransition,</span>
                &quot;The transition to be considered cannot be null&quot;);
<span class="fc" id="L355">        if (mapIntersectionTransitionIncomingTransition</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">                .containsKey(intersectionTransition)) {</span>
<span class="fc" id="L357">            return true;</span>
        }
<span class="fc" id="L359">        return false;</span>
    }

    /**
     * returns true if the intersection transition T is associated with an
     * outgoing transition
     * 
     * @param intersectionTransition
     *            is the transition of the intersection automaton
     * @return true if the transition of the intersection automaton is
     *         associated with a outgoing transition
     * @throws NullPointerException
     *             if the transition t is null
     */
    public boolean isOutTransition(Transition intersectionTransition) {
<span class="fc" id="L374">        Preconditions</span>
<span class="fc" id="L375">                .checkState(this.isPerformed(),</span>
                        &quot;You must compute the subproperties before performing this operation&quot;);
<span class="fc" id="L377">        Preconditions.checkNotNull(intersectionTransition,</span>
                &quot;The transition to be considered cannot be null&quot;);
<span class="fc" id="L379">        if (mapIntersectionTransitionOutgoingTransition</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">                .containsKey(intersectionTransition)) {</span>
<span class="fc" id="L381">            return true;</span>
        }
<span class="fc" id="L383">        return false;</span>
    }

    /**
     * return the outgoing transition associated with the intersection
     * transition T
     * 
     * @param intersectionTransition
     *            is the transition of the intersection automaton which is
     *            associated with an outgoing transition
     * @return the outgoing transition associated with the transition of the
     *         intersection automaton
     * @throws NullPointerException
     *             if the transition t is null
     * @throws IllegalArgumentException
     *             if the transition t is not associated with an outgoing
     *             transition
     */
    public LabeledPluggingTransition getOutgoingTransition(
            Transition intersectionTransition) {
<span class="fc" id="L403">        Preconditions</span>
<span class="fc" id="L404">                .checkState(this.isPerformed(),</span>
                        &quot;You must compute the subproperties before performing this operation&quot;);
<span class="fc" id="L406">        Preconditions.checkNotNull(intersectionTransition,</span>
                &quot;The transition to be considered cannot be null&quot;);
<span class="fc" id="L408">        Preconditions.checkArgument(</span>
<span class="fc" id="L409">                this.isOutTransition(intersectionTransition), &quot;The transition &quot;</span>
                        + intersectionTransition
                        + &quot; must be associated with an outgoing transition&quot;);
<span class="fc" id="L412">        LabeledPluggingTransition pluggingTransition=mapIntersectionTransitionOutgoingTransition</span>
<span class="fc" id="L413">                .get(intersectionTransition);</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">        if(!this.subProperty.getOutgoingTransitions().contains(pluggingTransition)){</span>
<span class="nc" id="L415">            throw new InternalError(&quot;The transition &quot;+pluggingTransition+&quot; is not contained into the set of outgoing transitions of the subProperty&quot;);</span>
        }

<span class="fc" id="L418">        return pluggingTransition;</span>
    }

    /**
     * return the in-coming port associated with the intersection transition T
     * 
     * @param intersectionTransition
     *            is the transition of the intersection automaton which is
     *            associated with a port
     * @return the in-coming port associated with the transition t
     * @throws NullPointerException
     *             if the transition t is null
     * @throws IllegalArgumentException
     *             if the transition t is not associated with a port
     */
    public LabeledPluggingTransition getIncomingTransition(
            Transition intersectionTransition) {
<span class="fc" id="L435">        Preconditions</span>
<span class="fc" id="L436">                .checkState(this.isPerformed(),</span>
                        &quot;You must compute the subproperties before performing this operation&quot;);
<span class="fc" id="L438">        Preconditions.checkNotNull(intersectionTransition,</span>
                &quot;The transition to be considered cannot be null&quot;);
<span class="fc" id="L440">        Preconditions.checkArgument(</span>
<span class="fc" id="L441">                this.isInTransition(intersectionTransition), &quot;The transition &quot;</span>
                        + intersectionTransition
                        + &quot; must be associated with a port&quot;);
<span class="fc" id="L444">        LabeledPluggingTransition pluggingTransition=mapIntersectionTransitionIncomingTransition</span>
<span class="fc" id="L445">                .get(intersectionTransition);</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">        if(!this.subProperty.getIncomingTransitions().contains(pluggingTransition)){</span>
<span class="nc" id="L447">            throw new InternalError(&quot;The transition &quot;+pluggingTransition+&quot; is not contained into the set of incoming transitions of the subProperty&quot;);</span>
        }
<span class="fc" id="L449">        return pluggingTransition;</span>
    }

    /**
     * returns a map that associates to each transition of the intersection
     * transition the corresponding incoming transition. If an intersection
     * transition is not associated with an incoming transition it is not
     * contained in the map
     * 
     * @return a map that associates to each transition of the intersection
     *         transition the corresponding incoming transition. If an
     *         intersection transition is not associated with an incoming
     *         transition it is not contained in the map
     * @throws IllegalStateException
     *             if the {@link SubPropertyIdentifier} is not performed before
     *             invoking this method
     */
    public Map&lt;Transition, LabeledPluggingTransition&gt; getMapIntersectionTransitionIncomingTransitions() {
<span class="fc" id="L467">        Preconditions</span>
<span class="fc" id="L468">                .checkState(</span>
<span class="fc" id="L469">                        this.isPerformed(),</span>
                        &quot;The map of the incoming ports can be obtained only after the sub-PropertyIdentifier has been performed&quot;);

<span class="fc" id="L472">        return Collections</span>
<span class="fc" id="L473">                .unmodifiableMap(mapIntersectionTransitionIncomingTransition);</span>
    }

    /**
     * returns a map that associates to each transition of the intersection
     * transition the corresponding outgoing transition. If an intersection
     * transition is not associated with an outgoing transition it is not
     * contained in the map
     * 
     * @return a map that associates to each transition of the intersection
     *         transition the corresponding outgoing transition. If an
     *         intersection transition is not associated with an outgoing
     *         transition it is not contained in the map
     * @throws IllegalStateException
     *             if the {@link SubPropertyIdentifier} is not performed before
     *             invoking this method
     */
    public Map&lt;Transition, LabeledPluggingTransition&gt; getMapIntersectionTransitionOutgoingTransitions() {
<span class="fc" id="L491">        Preconditions</span>
<span class="fc" id="L492">                .checkState(</span>
<span class="fc" id="L493">                        this.isPerformed(),</span>
                        &quot;The map of the outcoming ports can be obtained only after the sub-PropertyIdentifier has been performed&quot;);
<span class="fc" id="L495">        return Collections</span>
<span class="fc" id="L496">                .unmodifiableMap(mapIntersectionTransitionOutgoingTransition);</span>
    }

    /**
     * returns the checker which is associated with the specific sub-property
     * identifier
     * 
     * @return the checker associated with the sub-property identifier
     */
    public Checker getChecker() {
<span class="fc" id="L506">        return this.checker;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>
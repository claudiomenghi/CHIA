<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ReachabilityIdentifier.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CHIAContraintComputation</a> &gt; <a href="index.source.html" class="el_package">it.polimi.constraintcomputation.reachability</a> &gt; <span class="el_source">ReachabilityIdentifier.java</span></div><h1>ReachabilityIdentifier.java</h1><pre class="source lang-java linenums">package it.polimi.constraintcomputation.reachability;

import it.polimi.automata.IntersectionBA;
import it.polimi.automata.state.State;
import it.polimi.automata.transition.Transition;
import it.polimi.checker.abstractor.Abstractor;
import it.polimi.checker.intersection.IntersectionBuilder;
import it.polimi.constraintcomputation.reachability.statepresence.acceptingclaim.AcceptingClaimStatePathChecker;
import it.polimi.constraintcomputation.reachability.statepresence.acceptingmodel.AcceptingModelStatePathChecker;
import it.polimi.constraintcomputation.subpropertyidentifier.SubPropertyIdentifier;
import it.polimi.constraints.transitions.LabeledPluggingTransition;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;

import com.google.common.base.Preconditions;

/**
 * &lt;p&gt;
 * The ReachabilityIdentifier class allows to compute the reachability between
 * the incoming and outgoing transitions of the sub-properties and the
 * corresponding labels, through the internal private methods
 * computeLowerReachability and computeUpperReachability. 
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * The computeLowerReachability computes whether from an outgoing transition it
 * is possible to reach an incoming transition through a path that only involves
 * purely regular states of the intersection automaton. 
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * The computeUpperReachability computes for each sub-property whether from an
 * outgoing transition it is possible to reach an incoming transition through a
 * path that involves purely regular and mixed states which do not involve mixed
 * states of the sub-property. 
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * The ReachabilityIdentifier class modifies the SubProperty identifier in
 * relation with the lower and the upper reachability relations computed
 * &lt;/p&gt;
 * 
 * @author Claudio Menghi
 *
 */
public class ReachabilityIdentifier {

<span class="fc" id="L55">	DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy/MM/dd HH:mm:ss&quot;);</span>
	
	/**
	 * contains the CHIA logger
	 */
<span class="fc" id="L60">	private static final Logger LOGGER = Logger</span>
<span class="fc" id="L61">			.getLogger(ReachabilityIdentifier.class);</span>
	/**
	 * is the builder which is used to compute the intersection automaton
	 */
	private final IntersectionBuilder intersectionBuilder;

	/**
	 * is the identifier which has been used to generate the sub-properties
	 */
	private final SubPropertyIdentifier subPropertiesIdentifier;

	/**
	 * creates a new ReachabilityIdentifier component which is used to compute
	 * and update the reachability relation between the incoming and outgoing
	 * transitions of each sub-property computed by the SubPropertyIdentifier
	 * 
	 * @param subPropertiesIdentifier
	 *            is the component which has been used to compute the
	 *            sub-properties
	 * @throws NullPointerException
	 *             if one of the parameters is null
	 */
<span class="fc" id="L83">	public ReachabilityIdentifier(SubPropertyIdentifier subPropertiesIdentifier) {</span>
<span class="fc" id="L84">		Preconditions.checkNotNull(subPropertiesIdentifier,</span>
				&quot;The subproperties cannot be null&quot;);

<span class="fc" id="L87">		this.intersectionBuilder = subPropertiesIdentifier.getChecker()</span>
<span class="fc" id="L88">				.getUpperIntersectionBuilder();</span>
<span class="fc" id="L89">		this.subPropertiesIdentifier = subPropertiesIdentifier;</span>
<span class="fc" id="L90">	}</span>

	/**
	 * updates the reachability relation insider the
	 * {@link SubPropertyIdentifier}
	 */
	public void perform() {

		// gets the intersection transitions associated with an incoming
		// transition of the sub-property
<span class="fc" id="L100">		Set&lt;Transition&gt; intersectionTransitionsAssociatedWithAnIncomingPort = subPropertiesIdentifier</span>
<span class="fc" id="L101">				.getMapIntersectionTransitionIncomingTransitions().keySet();</span>
<span class="fc" id="L102">		LOGGER.debug(&quot;Number of intersection transitions associated with and incoming transition&quot;</span>
<span class="fc" id="L103">				+ intersectionTransitionsAssociatedWithAnIncomingPort.size());</span>

		// gets the intersection transitions associated with an outgoing
		// transition of the sub-property
<span class="fc" id="L107">		Set&lt;Transition&gt; intersectionTransitionsAssociatedWithAnOutgoingPort = subPropertiesIdentifier</span>
<span class="fc" id="L108">				.getMapIntersectionTransitionOutgoingTransitions().keySet();</span>
<span class="fc" id="L109">		LOGGER.debug(&quot;Number of intersection transitions associated with an outgoing transition&quot;</span>
<span class="fc" id="L110">				+ intersectionTransitionsAssociatedWithAnOutgoingPort.size());</span>

		// computes a map that associates for each state of the intersection
		// automaton the set of transitions of the intersection automaton
		// associated with an incoming transition of the sub-property
<span class="fc" id="L115">		Map&lt;State, Set&lt;Transition&gt;&gt; mapStateIncomingTransitionsAssociatedIncomingTransition = computeStateIncomingTransitions(</span>
<span class="fc" id="L116">				this.intersectionBuilder.getIntersectionAutomaton(),</span>
				intersectionTransitionsAssociatedWithAnIncomingPort);
<span class="fc" id="L118">		LOGGER.debug(&quot;Number of entry in the incoming transition map: &quot;</span>
				+ mapStateIncomingTransitionsAssociatedIncomingTransition
<span class="fc" id="L120">						.size());</span>

		// computes a map that associates for each state of the intersection
		// automaton the set of transitions of the intersection automaton
		// associated with an outgoing transition of the sub-property
<span class="fc" id="L125">		Map&lt;State, Set&lt;Transition&gt;&gt; mapStateOutGoingTransitionsAssociatedOutgoingTransition = computeStateOutgoingTransitions(</span>
<span class="fc" id="L126">				this.intersectionBuilder.getIntersectionAutomaton(),</span>
				intersectionTransitionsAssociatedWithAnOutgoingPort);
<span class="fc" id="L128">		LOGGER.debug(&quot;Number of entry in the outgoing transition map: &quot;</span>
				+ mapStateOutGoingTransitionsAssociatedOutgoingTransition
<span class="fc" id="L130">						.size());</span>

<span class="fc" id="L132">		LOGGER.debug(&quot;Computing the lower reachability map&quot;);</span>
		// first it updates the lower reachability relation
<span class="fc" id="L134">		this.computeLowerRechabilityRelation(</span>
				mapStateIncomingTransitionsAssociatedIncomingTransition,
				mapStateOutGoingTransitionsAssociatedOutgoingTransition);
<span class="fc" id="L137">		LOGGER.debug(&quot;Lower reachability map computed&quot;);</span>
<span class="fc" id="L138">		LOGGER.debug(&quot;compute upper reachability&quot;);</span>
		// second it updates the upper reachability relation
<span class="fc" id="L140">		this.computeUpperReachabilityRelation(</span>
				mapStateIncomingTransitionsAssociatedIncomingTransition,
				mapStateOutGoingTransitionsAssociatedOutgoingTransition);
<span class="fc" id="L143">		LOGGER.debug(&quot;upper reachability computed&quot;);</span>
<span class="fc" id="L144">	}</span>

	/**
	 * updates the lower reachability relation of the
	 * {@link SubPropertyIdentifier}
	 */
	private void computeLowerRechabilityRelation(
			Map&lt;State, Set&lt;Transition&gt;&gt; mapStateIncomingTransitionsAssociatedIncomingTransition,
			Map&lt;State, Set&lt;Transition&gt;&gt; mapStateOutGoingTransitionsAssociatedOutgoingTransition) {

		// gets the intersection automaton
<span class="fc" id="L155">		IntersectionBA intersectionAutomaton = this.intersectionBuilder</span>
<span class="fc" id="L156">				.getIntersectionAutomaton();</span>

		// considers only the purely regular states of the intersection
		// automaton
<span class="fc" id="L160">		IntersectionBA abstractedIntersection = new Abstractor&lt;IntersectionBA&gt;()</span>
<span class="fc" id="L161">				.perform(intersectionAutomaton,</span>
<span class="fc" id="L162">						intersectionAutomaton.getPurelyRegularStates());</span>

<span class="fc" id="L164">		Set&lt;State&gt; interestingSourceStates=this.getInterestingDestinationsStates(mapStateOutGoingTransitionsAssociatedOutgoingTransition, intersectionAutomaton);</span>
		
		// contains the source states of the incoming transitions
<span class="fc" id="L167">		Set&lt;State&gt; interestingDestinationStates=this.getInterestingSourceStates(mapStateIncomingTransitionsAssociatedIncomingTransition, intersectionAutomaton);</span>
		
		// computes the presence of accepting states of the claim in the
		// corresponding abstracted graph
<span class="fc" id="L171">		LOGGER.debug(&quot;lower: accepting claim states: &quot;);</span>
<span class="fc" id="L172">		AcceptingClaimStatePathChecker acceptingClaimStatePathChecker = new AcceptingClaimStatePathChecker(</span>
<span class="fc" id="L173">				abstractedIntersection.getPurelyRegularStates(),</span>
				intersectionBuilder, interestingSourceStates, interestingDestinationStates);

<span class="fc" id="L176">		LOGGER.debug(&quot;lower: accepting model states: &quot;);</span>
		// computes the presence of accepting states of the model in the
		// corresponding abstracted graph
<span class="fc" id="L179">		AcceptingModelStatePathChecker acceptingModelStatePathChecker = new AcceptingModelStatePathChecker(</span>
<span class="fc" id="L180">				abstractedIntersection.getPurelyRegularStates(),</span>
				intersectionBuilder, interestingSourceStates, interestingDestinationStates);

		
		
		// analyzes each reachability entry. &lt;s1, s2&gt; is a reachability entry if
		// from s1 it is possible to reach s2
<span class="fc" id="L187">		Map&lt;State, Set&lt;State&gt;&gt; reachabilityMap = this.getReachabilityRelation(</span>
<span class="fc" id="L188">				abstractedIntersection, abstractedIntersection.getPurelyRegularStates(),</span>
				mapStateOutGoingTransitionsAssociatedOutgoingTransition
<span class="fc" id="L190">						.keySet(),</span>
				mapStateIncomingTransitionsAssociatedIncomingTransition
<span class="fc" id="L192">						.keySet());</span>

<span class="fc bfc" id="L194" title="All 2 branches covered.">		for (State sourceState : reachabilityMap.keySet()) {</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">			for (State destinationState : reachabilityMap.get(sourceState)) {</span>
<span class="fc" id="L196">				if (mapStateOutGoingTransitionsAssociatedOutgoingTransition</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">						.containsKey(sourceState)) {</span>
<span class="fc" id="L198">					if (mapStateIncomingTransitionsAssociatedIncomingTransition</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">							.containsKey(destinationState)) {</span>

						for (Transition outTransition : mapStateOutGoingTransitionsAssociatedOutgoingTransition
<span class="fc bfc" id="L202" title="All 2 branches covered.">								.get(sourceState)) {</span>

							for (Transition inTransition : mapStateIncomingTransitionsAssociatedIncomingTransition
<span class="fc bfc" id="L205" title="All 2 branches covered.">									.get(destinationState)) {</span>

<span class="fc" id="L207">								LabeledPluggingTransition subPropertyOuttransition = this.subPropertiesIdentifier</span>
<span class="fc" id="L208">										.getOutgoingTransition(outTransition);</span>
<span class="fc" id="L209">								LabeledPluggingTransition subPropertyInTransition = this.subPropertiesIdentifier</span>
<span class="fc" id="L210">										.getIncomingTransition(inTransition);</span>

<span class="fc" id="L212">								State source = intersectionAutomaton</span>
<span class="fc" id="L213">										.getTransitionDestination(outTransition);</span>
<span class="fc" id="L214">								State destination = intersectionAutomaton</span>
<span class="fc" id="L215">										.getTransitionSource(inTransition);</span>
<span class="pc bpc" id="L216" title="2 of 4 branches missed.">								if(abstractedIntersection.getStates().contains(source) &amp;&amp; abstractedIntersection.getStates().contains(destination)){</span>
<span class="fc" id="L217">									this.subPropertiesIdentifier.perform()</span>
<span class="fc" id="L218">									.addReachabilityRelation(</span>
											subPropertyOuttransition,
											subPropertyInTransition,
											acceptingModelStatePathChecker
<span class="fc" id="L222">													.perform(source,</span>
															destination),
											acceptingClaimStatePathChecker
<span class="fc" id="L225">													.perform(source,</span>
															destination));
								}
<span class="fc" id="L228">							}</span>
<span class="fc" id="L229">						}</span>
					}
				}
<span class="fc" id="L232">			}</span>
<span class="fc" id="L233">		}</span>
<span class="fc" id="L234">	}</span>

	/**
	 * updates the upper reachability relation of the
	 * {@link SubPropertyIdentifier}
	 */
	private void computeUpperReachabilityRelation(
			Map&lt;State, Set&lt;Transition&gt;&gt; mapStateIncomingTransitionsAssociatedIncomingTransition,
			Map&lt;State, Set&lt;Transition&gt;&gt; mapStateOutGoingTransitionsAssociatedOutgoingTransition) {

		// gets the intersection automaton
<span class="fc" id="L245">		IntersectionBA intersectionAutomaton = this.intersectionBuilder</span>
<span class="fc" id="L246">				.getIntersectionAutomaton();</span>
		// gets the states of the intersection automaton
<span class="fc" id="L248">		Set&lt;State&gt; analyzedStates = new HashSet&lt;State&gt;(</span>
<span class="fc" id="L249">				intersectionAutomaton.getStates());</span>
		// removes from the states of the intersection automaton the states
		// involved in a sub-property
<span class="fc" id="L252">		analyzedStates.removeAll(this.subPropertiesIdentifier.perform()</span>
<span class="fc" id="L253">				.getAutomaton().getStates());</span>

		// computes the abstract intersection, i.e., it removes from the
		// intersection automaton the states of the automaton associated with
		// the sub-property
<span class="fc" id="L258">		IntersectionBA abstractedIntersection = new Abstractor&lt;IntersectionBA&gt;()</span>
<span class="fc" id="L259">				.perform(intersectionAutomaton, analyzedStates);</span>

<span class="fc" id="L261">		Set&lt;State&gt; interestingSourceStates=this.getInterestingDestinationsStates(mapStateOutGoingTransitionsAssociatedOutgoingTransition, intersectionAutomaton);</span>
<span class="fc" id="L262">		Set&lt;State&gt; interestingDestinationStates=this.getInterestingSourceStates(mapStateIncomingTransitionsAssociatedIncomingTransition, intersectionAutomaton);</span>
		// computes the presence states of accepting states of the claim
		// considering the set of analyzed states
<span class="fc" id="L265">		LOGGER.debug(&quot;upper: Accepting states&quot;);</span>
<span class="fc" id="L266">		AcceptingClaimStatePathChecker acceptingClaimStatePathChecker = new AcceptingClaimStatePathChecker(</span>
				analyzedStates, intersectionBuilder, interestingSourceStates, interestingDestinationStates);

		// computes the presence states of accepting states of the model
		// considering the set of analyzed states
<span class="fc" id="L271">		AcceptingModelStatePathChecker acceptingModelStatePathChecker = new AcceptingModelStatePathChecker(</span>
				analyzedStates, intersectionBuilder, interestingSourceStates, interestingDestinationStates);

<span class="fc" id="L274">		LOGGER.debug(&quot;upper: Accepting statesComputed&quot;);</span>
<span class="fc" id="L275">		LOGGER.debug(&quot;upper: Quering&quot;);</span>




		// analyzes each reachability entry. &lt;s1, s2&gt; is a reachability entry if
		// from s1 it is possible to reach s2
<span class="fc" id="L282">		Map&lt;State, Set&lt;State&gt;&gt; reachabilityMap = this.getReachabilityRelation(</span>
				abstractedIntersection, analyzedStates,
				mapStateOutGoingTransitionsAssociatedOutgoingTransition
<span class="fc" id="L285">						.keySet(),</span>
				mapStateIncomingTransitionsAssociatedIncomingTransition
<span class="fc" id="L287">						.keySet());</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">		for (State sourceState : reachabilityMap.keySet()) {</span>

<span class="fc bfc" id="L290" title="All 2 branches covered.">			for (State destinationState : reachabilityMap.get(sourceState)) {</span>
<span class="fc" id="L291">				if (mapStateOutGoingTransitionsAssociatedOutgoingTransition</span>
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">						.containsKey(sourceState)) {</span>
<span class="fc" id="L293">					if (mapStateIncomingTransitionsAssociatedIncomingTransition</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">							.containsKey(destinationState)) {</span>

						for (Transition outTransition : mapStateOutGoingTransitionsAssociatedOutgoingTransition
<span class="fc bfc" id="L297" title="All 2 branches covered.">								.get(sourceState)) {</span>

							for (Transition inTransition : mapStateIncomingTransitionsAssociatedIncomingTransition
<span class="fc bfc" id="L300" title="All 2 branches covered.">									.get(destinationState)) {</span>

<span class="fc" id="L302">								LabeledPluggingTransition subPropertyOuttransition = this.subPropertiesIdentifier</span>
<span class="fc" id="L303">										.getOutgoingTransition(outTransition);</span>
<span class="fc" id="L304">								LabeledPluggingTransition subPropertyInTransition = this.subPropertiesIdentifier</span>
<span class="fc" id="L305">										.getIncomingTransition(inTransition);</span>

<span class="fc" id="L307">								State source = intersectionAutomaton</span>
<span class="fc" id="L308">										.getTransitionDestination(outTransition);</span>
<span class="fc" id="L309">								State destination = intersectionAutomaton</span>
<span class="fc" id="L310">										.getTransitionSource(inTransition);</span>
<span class="fc" id="L311">								this.subPropertiesIdentifier.perform()</span>
<span class="fc" id="L312">										.addPossibleReachabilityRelation(</span>
												subPropertyOuttransition,
												subPropertyInTransition,
												acceptingModelStatePathChecker
<span class="fc" id="L316">														.perform(source,</span>
																destination),
												acceptingClaimStatePathChecker
<span class="fc" id="L319">														.perform(source,</span>
																destination));

<span class="fc" id="L322">							}</span>
<span class="fc" id="L323">						}</span>

					}
				}
<span class="fc" id="L327">			}</span>
<span class="fc" id="L328">		}</span>
<span class="fc" id="L329">		LOGGER.debug(&quot;Sub-property upper reachability relation size &quot;</span>
<span class="fc" id="L330">				+ this.subPropertiesIdentifier.perform()</span>
<span class="fc" id="L331">						.getUpperReachabilityRelation()</span>
<span class="fc" id="L332">						.getReachabilityAcceptingMap().size());</span>

<span class="fc" id="L334">		LOGGER.debug(&quot;end: reachability&quot;);</span>
<span class="fc" id="L335">	}</span>

	private Set&lt;State&gt; getInterestingDestinationsStates(
			Map&lt;State, Set&lt;Transition&gt;&gt; mapStateOutGoingTransitionsAssociatedOutgoingTransition,
			IntersectionBA intersectionAutomaton) {
<span class="fc" id="L340">		Set&lt;State&gt; interestingSourceStates = new HashSet&lt;State&gt;();</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">		for (Set&lt;Transition&gt; outTransitions : mapStateOutGoingTransitionsAssociatedOutgoingTransition</span>
<span class="fc" id="L342">				.values()) {</span>

<span class="fc bfc" id="L344" title="All 2 branches covered.">			for (Transition outTransition : outTransitions) {</span>
<span class="fc" id="L345">				State source = intersectionAutomaton</span>
<span class="fc" id="L346">						.getTransitionDestination(outTransition);</span>
<span class="fc" id="L347">				interestingSourceStates.add(source);</span>

<span class="fc" id="L349">			}</span>
<span class="fc" id="L350">		}</span>
<span class="fc" id="L351">		return interestingSourceStates;</span>
	}
	
	private Set&lt;State&gt; getInterestingSourceStates(
			Map&lt;State, Set&lt;Transition&gt;&gt; mapStateOutGoingTransitionsAssociatedIncomingTransition,
			IntersectionBA intersectionAutomaton) {
<span class="fc" id="L357">		Set&lt;State&gt; interestingDestinationStates = new HashSet&lt;State&gt;();</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">		for (Set&lt;Transition&gt; inTransitions : mapStateOutGoingTransitionsAssociatedIncomingTransition</span>
<span class="fc" id="L359">				.values()) {</span>

<span class="fc bfc" id="L361" title="All 2 branches covered.">			for (Transition inTransition : inTransitions) {</span>
<span class="fc" id="L362">				State source = intersectionAutomaton.getTransitionSource(inTransition);</span>
<span class="fc" id="L363">				interestingDestinationStates.add(source);</span>

<span class="fc" id="L365">			}</span>
<span class="fc" id="L366">		}</span>
<span class="fc" id="L367">		return interestingDestinationStates;</span>
	}


	/**
	 * @param intersectionAutomaton
	 * @param intersectionTransitionsAssociatedWithAnOutgoingPort
	 * @return
	 */
	private Map&lt;State, Set&lt;Transition&gt;&gt; computeStateOutgoingTransitions(
			IntersectionBA intersectionAutomaton,
			Set&lt;Transition&gt; intersectionTransitionsAssociatedWithAnOutgoingPort) {
<span class="fc" id="L379">		Map&lt;State, Set&lt;Transition&gt;&gt; mapStateOutGoingTransitionsAssociatedOutgoingTransition = new HashMap&lt;State, Set&lt;Transition&gt;&gt;();</span>

<span class="fc bfc" id="L381" title="All 2 branches covered.">		for (Transition outTransition : intersectionTransitionsAssociatedWithAnOutgoingPort) {</span>

<span class="fc" id="L383">			State outTransitionDestination = intersectionAutomaton</span>
<span class="fc" id="L384">					.getTransitionDestination(outTransition);</span>
<span class="fc" id="L385">			if (!mapStateOutGoingTransitionsAssociatedOutgoingTransition</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">					.containsKey(outTransitionDestination)) {</span>
<span class="fc" id="L387">				mapStateOutGoingTransitionsAssociatedOutgoingTransition.put(</span>
						outTransitionDestination, new HashSet&lt;Transition&gt;());
			}
<span class="fc" id="L390">			mapStateOutGoingTransitionsAssociatedOutgoingTransition.get(</span>
<span class="fc" id="L391">					outTransitionDestination).add(outTransition);</span>
<span class="fc" id="L392">		}</span>

<span class="fc" id="L394">		LOGGER.debug(&quot;mapStateOutGoingTransitionsAssociatedOutgoingTransition &quot;</span>
				+ mapStateOutGoingTransitionsAssociatedOutgoingTransition
<span class="fc" id="L396">						.size());</span>
<span class="fc" id="L397">		return mapStateOutGoingTransitionsAssociatedOutgoingTransition;</span>
	}

	/**
	 * computes a map that associates for each state of the intersection
	 * automaton the set of transitions of the intersection automaton associated
	 * with an incoming transition of the sub-property
	 * 
	 * @param intersectionAutomaton
	 *            the intersection automaton to be considered
	 * @param intersectionTransitionsAssociatedWithAnIncomingPort
	 *            the set of transitions of the intersection automaton
	 *            associated with an incoming transition of the sub-property
	 * @return a map that associates for each state of the intersection
	 *         automaton the set of transitions of the intersection automaton
	 *         associated with an incoming transition of the sub-property
	 */
	private Map&lt;State, Set&lt;Transition&gt;&gt; computeStateIncomingTransitions(
			IntersectionBA intersectionAutomaton,
			Set&lt;Transition&gt; intersectionTransitionsAssociatedWithAnIncomingPort) {
<span class="fc" id="L417">		Map&lt;State, Set&lt;Transition&gt;&gt; mapStateIncomingTransitionsAssociatedIncomingTransition = new HashMap&lt;State, Set&lt;Transition&gt;&gt;();</span>

<span class="fc bfc" id="L419" title="All 2 branches covered.">		for (Transition inTransition : intersectionTransitionsAssociatedWithAnIncomingPort) {</span>

<span class="fc" id="L421">			State inTransitionSource = intersectionAutomaton</span>
<span class="fc" id="L422">					.getTransitionSource(inTransition);</span>
<span class="fc" id="L423">			if (!mapStateIncomingTransitionsAssociatedIncomingTransition</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">					.containsKey(inTransitionSource)) {</span>
<span class="fc" id="L425">				mapStateIncomingTransitionsAssociatedIncomingTransition.put(</span>
						inTransitionSource, new HashSet&lt;Transition&gt;());
			}
<span class="fc" id="L428">			mapStateIncomingTransitionsAssociatedIncomingTransition.get(</span>
<span class="fc" id="L429">					inTransitionSource).add(inTransition);</span>
<span class="fc" id="L430">		}</span>
<span class="fc" id="L431">		LOGGER.debug(&quot;mapStateIncomingTransitionsAssociatedIncomingTransition &quot;</span>
				+ mapStateIncomingTransitionsAssociatedIncomingTransition
<span class="fc" id="L433">						.size());</span>
<span class="fc" id="L434">		return mapStateIncomingTransitionsAssociatedIncomingTransition;</span>
	}

	/**
	 * returns the set of reachability entries of the corresponding graph
	 * 
	 * @param paths
	 *            the paths to be considered
	 * @param states
	 *            the set of the states under analysis
	 * @return a set of entry &lt;state, state&gt; a couple &lt;s1, s2&gt; is in the set if
	 *         from s1 it is possible to reach s2
	 */
	private Map&lt;State, Set&lt;State&gt;&gt; getReachabilityRelation(IntersectionBA abstractedIntersection,
			 Set&lt;State&gt; states,
			Set&lt;State&gt; sourceStates, Set&lt;State&gt; destinationStates) {
<span class="fc" id="L450">		Preconditions.checkNotNull(abstractedIntersection, &quot;The abstracted intersection cannot be null&quot;);</span>
<span class="fc" id="L451">		Preconditions.checkNotNull(states, &quot;The states cannot be null&quot;);</span>
		

		// computes the reachability between the shortest paths between the
		// states of the graph
<span class="fc" id="L456">		LOGGER.debug(&quot;lower: Floyd warshall&quot;);</span>
		
<span class="fc" id="L458">		ReachableStatesIdentifier identifier=new ReachableStatesIdentifier(abstractedIntersection);</span>
		
<span class="fc" id="L460">		Map&lt;State, Set&lt;State&gt;&gt; reachabilityMap = new HashMap&lt;State, Set&lt;State&gt;&gt;();</span>

<span class="fc bfc" id="L462" title="All 2 branches covered.">		for (State sourceState: sourceStates) {</span>
<span class="fc" id="L463">			reachabilityMap.put(sourceState, identifier.getReachableStates(sourceState, destinationStates));</span>
<span class="fc" id="L464">		}</span>
		
<span class="fc" id="L466">		LOGGER.debug(&quot;reachability entries to be analyzed:&quot;</span>
<span class="fc" id="L467">				+ reachabilityMap.size());</span>
<span class="fc" id="L468">		return reachabilityMap;</span>
	}
	/*private Map&lt;State, Set&lt;State&gt;&gt; getReachabilityRelation(IntersectionBA abstractedIntersection,
			 Set&lt;State&gt; states,
			Set&lt;State&gt; sourceStates, Set&lt;State&gt; destinationStates) {
		Preconditions.checkNotNull(abstractedIntersection, &quot;The abstracted intersection cannot be null&quot;);
		Preconditions.checkNotNull(states, &quot;The states cannot be null&quot;);
		
		/// gets the corresponding graph
		DirectedGraph&lt;State, Transition&gt; graph = abstractedIntersection
				.getGraph();

		// computes the reachability between the shortest paths between the
		// states of the graph
		LOGGER.debug(&quot;lower: Floyd warshall&quot;);
		
		Collection&lt;GraphPath&lt;State, Transition&gt;&gt; paths = new FloydWarshallShortestPaths&lt;State, Transition&gt;(
				graph).getShortestPaths();

		
		Map&lt;State, Set&lt;State&gt;&gt; reachabilityMap = new HashMap&lt;State, Set&lt;State&gt;&gt;();

		for (Iterator&lt;GraphPath&lt;State, Transition&gt;&gt; iterator = paths.iterator(); iterator
				.hasNext();) {
			GraphPath&lt;State, Transition&gt; path = iterator.next();
			if (sourceStates.contains(path.getStartVertex())
					&amp;&amp; destinationStates.contains(path.getEndVertex())) {
				if (reachabilityMap.containsKey(path.getStartVertex())) {
					reachabilityMap.get(path.getStartVertex()).add(
							path.getEndVertex());
				} else {
					reachabilityMap.put(path.getStartVertex(),
							new HashSet&lt;State&gt;());
					reachabilityMap.get(path.getStartVertex()).add(
							path.getEndVertex());
				}
			}

			iterator.remove();
		}
		for (State state : states) {
			if (sourceStates.contains(state)
					&amp;&amp; destinationStates.contains(state))
				if (reachabilityMap.containsKey(state)) {
					reachabilityMap.get(state).add(state);
				} else {
					reachabilityMap.put(state, new HashSet&lt;State&gt;());
					reachabilityMap.get(state).add(state);
				}
		}
		LOGGER.debug(&quot;reachability entries to be analyzed:&quot;
				+ reachabilityMap.size());
		return reachabilityMap;
	}*/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>
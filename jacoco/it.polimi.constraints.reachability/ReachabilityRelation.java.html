<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ReachabilityRelation.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CHIAConstraint</a> &gt; <a href="index.source.html" class="el_package">it.polimi.constraints.reachability</a> &gt; <span class="el_source">ReachabilityRelation.java</span></div><h1>ReachabilityRelation.java</h1><pre class="source lang-java linenums">package it.polimi.constraints.reachability;

import it.polimi.automata.state.State;
import it.polimi.constraints.transitions.LabeledPluggingTransition;

import java.util.Collection;

import com.google.common.base.Preconditions;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimap;

/**
 * contains the reachability relation. The reachability relation specified
 * whether an incoming port of a sub-property is reachable from the outgoing
 * port of the same transition
 * 
 * @author Claudio Menghi
 *
 */
public class ReachabilityRelation {

	/**
	 * If a state is the source of a reachability relation, contains the state
	 * and the corresponding reabhability entry
	 */
	private final Multimap&lt;State, ReachabilityEntry&gt; reachabilityMap;

	/**
	 * creates a new empty reachability relation. The reachability relation is
	 * used to map the incoming transitions which are reachable from the
	 * outgoing transition of the same component
	 */
<span class="fc" id="L33">	public ReachabilityRelation() {</span>
<span class="fc" id="L34">		this.reachabilityMap = HashMultimap.create();</span>
<span class="fc" id="L35">	}</span>

	/**
	 * adds the transition to the reachability relation. The sourceTransition is
	 * the outgoingPort of the sub-property from which the destinationTransition
	 * can be reached. The destinationTransition is the incoming port of the
	 * subproperty which is reachable from the sourceTransition
	 * 
	 * @param outgoingTransition
	 *            the outgoing transition to be considered
	 * @param incomingTransition
	 *            the incoming transition to be considered
	 * @param modelAccepting
	 *            true if an accepting state of the model is present from the
	 *            outgoing to the incoming transition
	 * @param claimAccepting
	 *            true if an accepting state of the claim is present from the
	 *            outgoint to the incoming transition
	 * @throws NullPointerException
	 *             if one of the two transitions is null
	 * @throws IllegalArgumentException
	 *             if the incoming or the outgoing transition is not
	 *             incoming/outgoing
	 */
	public void addTransition(LabeledPluggingTransition outgoingTransition,
			LabeledPluggingTransition incomingTransition,
			Boolean modelAccepting, Boolean claimAccepting) {
<span class="fc" id="L62">		Preconditions.checkNotNull(outgoingTransition,</span>
<span class="fc" id="L63">				&quot;The outgoing transition cannot be null&quot;);</span>
<span class="fc" id="L64">		Preconditions.checkNotNull(incomingTransition,</span>
<span class="fc" id="L65">				&quot;The destination transition cannot be null&quot;);</span>
		Preconditions
<span class="fc bfc" id="L67" title="All 2 branches covered.">				.checkArgument(!outgoingTransition.isIncoming(),</span>
<span class="fc" id="L68">						&quot;The source of the reachability relation must be an outgoingTransition&quot;);</span>
		Preconditions
<span class="fc" id="L70">				.checkArgument(incomingTransition.isIncoming(),</span>
<span class="fc" id="L71">						&quot;The destination of the reachability relation must be an incomingTransition&quot;);</span>

<span class="fc" id="L73">		ReachabilityEntry reachabilityEntry = new ReachabilityEntry(</span>
<span class="fc" id="L74">				incomingTransition, outgoingTransition, modelAccepting,</span>
<span class="fc" id="L75">				claimAccepting);</span>
<span class="fc" id="L76">		this.reachabilityMap.put(outgoingTransition.getSource(),</span>
<span class="fc" id="L77">				reachabilityEntry);</span>
<span class="fc" id="L78">	}</span>

	/**
	 * returns the map that associates for each state the corresponding
	 * reachability entries
	 * 
	 * @return the map that associates for each state the corresponding
	 *         reachability entries
	 */
	public Multimap&lt;State, ReachabilityEntry&gt; getReachabilityAcceptingMap() {
<span class="fc" id="L88">		return this.reachabilityMap;</span>
	}

	/**
	 * returns the collection of reachability entries associated to one state
	 * 
	 * @param subPropertyState
	 *            the state of the sub-property to be considered
	 * @return the set of the reachability entries whose source is the specified
	 *         property state
	 */
	public Collection&lt;ReachabilityEntry&gt; get(State subPropertyState) {
<span class="fc" id="L100">		return this.reachabilityMap.get(subPropertyState);</span>
	}

	/**
	 * {@inheritDoc}
	 */
	@Override
	public String toString() {
<span class="fc" id="L108">		return &quot;ReachabilityRelation [acceptingMap=&quot; + reachabilityMap + &quot;]&quot;;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>
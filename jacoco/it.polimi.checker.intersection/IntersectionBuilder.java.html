<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>IntersectionBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CHIAChecker</a> &gt; <a href="index.source.html" class="el_package">it.polimi.checker.intersection</a> &gt; <span class="el_source">IntersectionBuilder.java</span></div><h1>IntersectionBuilder.java</h1><pre class="source lang-java linenums">package it.polimi.checker.intersection;

import it.polimi.action.CHIAAction;
import it.polimi.automata.BA;
import it.polimi.automata.IBA;
import it.polimi.automata.IntersectionBA;
import it.polimi.automata.state.IntersectionStateFactory;
import it.polimi.automata.state.State;
import it.polimi.automata.transition.ClaimTransitionFactory;
import it.polimi.automata.transition.Transition;
import it.polimi.checker.intersection.acceptingpolicies.AcceptingPolicy;
import it.polimi.checker.intersection.acceptingpolicies.KripkeAcceptingPolicy;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.tuple.ImmutableTriple;
import org.apache.commons.lang3.tuple.Triple;

import com.google.common.base.Preconditions;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.Multimaps;
import com.google.common.collect.SetMultimap;

/**
 * Computes the intersection between an Incomplete Buchi automaton and a Buchi
 * Automaton
 * 
 * @author Claudio Menghi
 */
public class IntersectionBuilder extends CHIAAction&lt;IntersectionBA&gt; {

	private final static String NAME = &quot;COMPUTE INTERSECTION&quot;;
	/**
	 * contains the intersection automaton generated
	 */
	private IntersectionBA intersection;

	/**
	 * contains the set of the visited states
	 */
	private final Set&lt;Triple&lt;State, State, Integer&gt;&gt; visitedStates;

	/**
	 * contains the intersection rule which is used to build the intersection
	 * transitions
	 */
	private final IntersectionTransitionBuilder intersectionTransitionBuilder;

	/**
	 * contains a map that associate to each constraint transition the
	 * corresponding model state
	 */
	private final Map&lt;Transition, State&gt; mapConstrainedTransitionModelBlackBoxState;
	private final SetMultimap&lt;State, Transition&gt; mapBlackBoxStateConstrainedTransition;

	/**
	 * Keeps track of the created states. For each couple of state of the model
	 * and of the claim, given an integer returns the state of the intersection
	 * automaton
	 */
	private final Map&lt;State, Map&lt;State, Map&lt;Integer, State&gt;&gt;&gt; createdStates;

	private final Map&lt;State, Integer&gt; intersectionStateNumber;
	/**
	 * for each state of the model contains the corresponding states of the
	 * intersection automaton
	 */
	private final Map&lt;State, State&gt; intersectionStateModelStateMap;
	private SetMultimap&lt;State, State&gt; modelStateintersectionStateMap;

	/**
	 * for each state of the claim contains the corresponding states of the
	 * intersection automaton
	 */
	private final Map&lt;State, State&gt; intersectionStateClaimStateMap;
	private SetMultimap&lt;State, State&gt; claimStateintersectionStateMap;

	/**
	 * contains the model to be considered in the intersection procedure
	 */
	private final IBA model;

	/**
	 * contains the claim to be considered in the intersection procedure
	 */
	private final BA claim;

	/**
	 * contains the factory which is used to create the states of the
	 * intersection automaton
	 */
	private final IntersectionStateFactory intersectionStateFactory;

	/**
	 * is the accepting policy to be used in the computation of the intersection
	 * automaton
	 */
	private final AcceptingPolicy acceptingPolicy;

	/**
	 * crates a new {@link IntersectionBuilder} which is in charge of computing
	 * the intersection automaton
	 * 
	 * @param acceptingPolicy
	 *            is the policy to be used to identify the accepting state of
	 *            the intersection automaton
	 * @param model
	 *            is the model to be considered in the intersection procedure
	 * @param claim
	 *            is the claim to be considered in the intersection procedure
	 * @throws NullPointerException
	 *             if one of the parameters is null
	 */
	public IntersectionBuilder(IBA model, BA claim,
			AcceptingPolicy acceptingPolicy) {
<span class="fc" id="L120">		super(NAME);</span>
<span class="fc" id="L121">		Preconditions.checkNotNull(model,</span>
<span class="fc" id="L122">				&quot;The model of the system cannot be null&quot;);</span>
<span class="fc" id="L123">		Preconditions.checkNotNull(claim, &quot;The claim cannot be null&quot;);</span>
<span class="fc" id="L124">		Preconditions.checkNotNull(acceptingPolicy,</span>
<span class="fc" id="L125">				&quot;The accepting policy cannot be null&quot;);</span>
		;

<span class="fc" id="L128">		this.intersectionStateModelStateMap = new HashMap&lt;State, State&gt;();</span>
<span class="fc" id="L129">		this.modelStateintersectionStateMap = HashMultimap.create();</span>
<span class="fc" id="L130">		this.intersectionStateClaimStateMap = new HashMap&lt;State, State&gt;();</span>
<span class="fc" id="L131">		this.claimStateintersectionStateMap = HashMultimap.create();</span>
<span class="fc" id="L132">		this.mapBlackBoxStateConstrainedTransition = HashMultimap.create();</span>
<span class="fc" id="L133">		this.acceptingPolicy = acceptingPolicy;</span>
<span class="fc" id="L134">		this.acceptingPolicy.setClaim(claim);</span>
<span class="fc" id="L135">		this.acceptingPolicy.setModel(model);</span>
		/*
		 * if (acceptingPolicy instanceof KripkeAcceptingPolicy) { Preconditions
		 * .checkArgument( model.getAcceptStates().containsAll(
		 * model.getStates()),
		 * &quot;The Kripke accepting policy is not consistend with the current model. All the states of the model must be accepting for the Kripke policy to be used &quot;
		 * ); }
		 */
<span class="fc" id="L143">		this.intersectionTransitionBuilder = new IntersectionTransitionBuilder();</span>
<span class="fc" id="L144">		this.intersection = new IntersectionBA();</span>
<span class="fc" id="L145">		this.model = model;</span>
<span class="fc" id="L146">		this.claim = claim;</span>
<span class="fc" id="L147">		this.mapConstrainedTransitionModelBlackBoxState = new HashMap&lt;Transition, State&gt;();</span>
<span class="fc" id="L148">		this.visitedStates = new HashSet&lt;Triple&lt;State, State, Integer&gt;&gt;();</span>
<span class="fc" id="L149">		this.createdStates = new HashMap&lt;State, Map&lt;State, Map&lt;Integer, State&gt;&gt;&gt;();</span>
<span class="fc" id="L150">		this.intersectionStateFactory = new IntersectionStateFactory();</span>
<span class="fc" id="L151">		this.intersectionStateNumber = new HashMap&lt;State, Integer&gt;();</span>
<span class="fc" id="L152">	}</span>

	/**
	 * computes the intersection of the model and the claim specified as
	 * parameter
	 * 
	 * @return the intersection of this automaton and the automaton a2
	 */
	public IntersectionBA perform() {
<span class="fc bfc" id="L161" title="All 2 branches covered.">		if (!this.isPerformed()) {</span>
<span class="fc" id="L162">			this.updateAlphabet();</span>

<span class="fc bfc" id="L164" title="All 2 branches covered.">			for (State modelInit : model.getInitialStates()) {</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">				for (State claimInit : claim.getInitialStates()) {</span>
<span class="fc" id="L166">					this.computeIntersection(modelInit, claimInit,</span>
<span class="fc" id="L167">							this.acceptingPolicy.comuteInitNumber(modelInit,</span>
<span class="fc" id="L168">									claimInit));</span>
				}
			}
<span class="fc" id="L171">			Multimaps.invertFrom(</span>
<span class="fc" id="L172">					Multimaps.forMap(this.intersectionStateClaimStateMap),</span>
<span class="fc" id="L173">					this.claimStateintersectionStateMap);</span>
<span class="fc" id="L174">			Multimaps.invertFrom(</span>
<span class="fc" id="L175">					Multimaps.forMap(this.intersectionStateModelStateMap),</span>
<span class="fc" id="L176">					this.modelStateintersectionStateMap);</span>

<span class="fc" id="L178">			Multimaps.invertFrom(Multimaps</span>
<span class="fc" id="L179">					.forMap(this.mapConstrainedTransitionModelBlackBoxState),</span>
<span class="fc" id="L180">					this.mapBlackBoxStateConstrainedTransition);</span>

<span class="fc" id="L182">			this.performed();</span>
		}
<span class="fc" id="L184">		return this.intersection;</span>
	}

	/**
	 * @return the mapModelStateIntersectionTransitions
	 */
	public Map&lt;Transition, State&gt; getIntersectionTransitionsBlackBoxStatesMap() {
<span class="fc" id="L191">		return Collections</span>
<span class="fc" id="L192">				.unmodifiableMap(mapConstrainedTransitionModelBlackBoxState);</span>
	}

	/**
	 * removes the intersection state from the intersection automaton and the
	 * maps used to store the relationships between the states of the model and
	 * the claim and the intersection automaton
	 * 
	 * @param intersectionState
	 *            the intersection state to be removed
	 * @throws NullPointerException
	 *             if the intersection state is null
	 * @throws IllegalStateException
	 *             if the intersection automaton has still to be computed
	 * @throws IllegalArgumentException
	 *             if the intersection state is not in the set of the states of
	 *             the intersection automaton
	 */
	public void removeIntersectionState(State intersectionState) {
		Preconditions
<span class="fc" id="L212">				.checkState(</span>
<span class="fc" id="L213">						this.isPerformed(),</span>
<span class="fc" id="L214">						&quot;It is not possible to remove an intersection state if the intersection has still to be computed&quot;);</span>
<span class="fc" id="L215">		Preconditions.checkNotNull(intersectionState,</span>
<span class="fc" id="L216">				&quot;The intersection state cannot be null&quot;);</span>
		
<span class="fc" id="L218">		Preconditions.checkArgument(this.intersection.getStates().contains(intersectionState),</span>
<span class="fc" id="L219">		        &quot;The state &quot;+intersectionState+&quot; to be removed must be contained into the set of the states of the automaton&quot;);</span>
<span class="fc" id="L220">		this.intersectionStateClaimStateMap.remove(intersectionState);</span>
<span class="fc" id="L221">		this.intersectionStateModelStateMap.remove(intersectionState);</span>
<span class="fc" id="L222">		this.mapBlackBoxStateConstrainedTransition.removeAll(intersectionState);</span>

<span class="fc" id="L224">		this.claimStateintersectionStateMap = HashMultimap.create();</span>
<span class="fc" id="L225">		this.modelStateintersectionStateMap = HashMultimap.create();</span>

<span class="fc" id="L227">		Multimaps.invertFrom(</span>
<span class="fc" id="L228">				Multimaps.forMap(this.intersectionStateClaimStateMap),</span>
<span class="fc" id="L229">				this.claimStateintersectionStateMap);</span>
<span class="fc" id="L230">		Multimaps.invertFrom(</span>
<span class="fc" id="L231">				Multimaps.forMap(this.intersectionStateModelStateMap),</span>
<span class="fc" id="L232">				this.modelStateintersectionStateMap);</span>

<span class="fc bfc" id="L234" title="All 2 branches covered.">		for (Transition t : this.intersection</span>
<span class="fc" id="L235">				.getInTransitions(intersectionState)) {</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">			if (this.mapConstrainedTransitionModelBlackBoxState.containsKey(t)) {</span>
<span class="fc" id="L237">				State blackboxState = this.mapConstrainedTransitionModelBlackBoxState</span>
<span class="fc" id="L238">						.get(t);</span>
<span class="fc" id="L239">				this.mapBlackBoxStateConstrainedTransition.get(blackboxState)</span>
<span class="fc" id="L240">						.remove(t);</span>
<span class="fc" id="L241">				this.mapConstrainedTransitionModelBlackBoxState.remove(t);</span>
			}
		}

<span class="fc bfc" id="L245" title="All 2 branches covered.">		for (Transition t : this.intersection</span>
<span class="fc" id="L246">				.getOutTransitions(intersectionState)) {</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">			if (this.mapConstrainedTransitionModelBlackBoxState.containsKey(t)) {</span>
<span class="fc" id="L248">				State blackBoxState = this.mapConstrainedTransitionModelBlackBoxState</span>
<span class="fc" id="L249">						.get(t);</span>
<span class="fc" id="L250">				this.mapBlackBoxStateConstrainedTransition.get(blackBoxState)</span>
<span class="fc" id="L251">						.remove(t);</span>
<span class="fc" id="L252">				this.mapConstrainedTransitionModelBlackBoxState.remove(t);</span>
			}
		}
<span class="fc" id="L255">		this.intersection.removeState(intersectionState);</span>
<span class="fc" id="L256">	}</span>

	/**
	 * The intersection computation starts from the initial state of the claim
	 * and the model and computes the intersection automaton. For this reason,
	 * if a particular state of the model or of the claim is not reachable from
	 * the initial state of the model or the claim, no states of the
	 * intersection automaton corresponding to this state are generated. The
	 * update intersection method allows the computation of the portion of the
	 * state space starting from the specified model state, claim state and
	 * number
	 * 
	 * @param modelState
	 *            is the state of the model to be considered
	 * @param claimState
	 *            is the state of the claim to be considered
	 * @param number
	 *            is the &quot;initial number&quot; from which the computation must start
	 * @throws NullPointerException
	 *             if the model state or the claim state is null
	 * @throws IllegalArgumentException
	 *             if the modelState or the claimState is not a state of the
	 *             model or the claim or if no state is associated with the
	 *             model state, claim state and number
	 * @throws IllegalStateException
	 *             if the intersection has still to be computed
	 */
	public void updateIntersection(State modelState, State claimState,
			int number) {
<span class="fc" id="L285">		Preconditions.checkState(this.isPerformed(),</span>
<span class="fc" id="L286">				&quot;The intersection has still not be computed&quot;);</span>

<span class="fc" id="L288">		Preconditions.checkNotNull(claimState,</span>
<span class="fc" id="L289">				&quot;The state of the claim cannot be null&quot;);</span>
<span class="fc" id="L290">		Preconditions.checkNotNull(modelState,</span>
<span class="fc" id="L291">				&quot;The state of the model cannot be null&quot;);</span>
		Preconditions
<span class="fc" id="L293">				.checkArgument(</span>
<span class="fc" id="L294">						this.claim.getStates().contains(claimState),</span>
<span class="fc" id="L295">						&quot;The state &quot;</span>
<span class="fc" id="L296">								+ claimState</span>
<span class="fc" id="L297">								+ &quot; is not contained into the set of the states of the claim&quot;);</span>
		Preconditions
<span class="fc" id="L299">				.checkArgument(</span>
<span class="fc" id="L300">						this.model.getStates().contains(modelState),</span>
<span class="fc" id="L301">						&quot;The state &quot;</span>
<span class="fc" id="L302">								+ modelState</span>
<span class="fc" id="L303">								+ &quot; is not contained into the set of the states of the model&quot;);</span>
<span class="fc bfc" id="L304" title="All 4 branches covered.">		Preconditions.checkArgument(number &gt;= 0 &amp;&amp; number &lt;= 2,</span>
<span class="fc" id="L305">				&quot;The number must be between 0 and 2&quot;);</span>

<span class="fc" id="L307">		this.computeIntersection(modelState, claimState, number);</span>
<span class="fc" id="L308">	}</span>

	/**
	 * returns the set of the states of the intersection automaton associated
	 * with the specified state of the claim and of the model
	 * 
	 * @param claimState
	 *            is the state of the claim that is considered
	 * @param modelState
	 *            is the state of the model that is considered
	 * @return the set of the states of the intersection automaton associated
	 *         with the state of the claim and of the model specified as
	 *         parameter
	 * @throws NullPointerException
	 *             if one of the states is null
	 * @throws IllegalArgumentException
	 *             if the state of the claim is not contained into the claim or
	 *             if the state of the model is not contained into the model
	 * @throws IllegalStateException
	 *             if the intersection has still to be computed
	 */
	public Set&lt;State&gt; getIntersectionStates(State modelState, State claimState) {
<span class="fc" id="L330">		Preconditions.checkState(this.isPerformed(),</span>
<span class="fc" id="L331">				&quot;The intersection has still not be computed&quot;);</span>
<span class="fc" id="L332">		Preconditions.checkNotNull(claimState,</span>
<span class="fc" id="L333">				&quot;The state of the claim cannot be null&quot;);</span>
<span class="fc" id="L334">		Preconditions.checkNotNull(modelState,</span>
<span class="fc" id="L335">				&quot;The state of the model cannot be null&quot;);</span>
		Preconditions
<span class="fc" id="L337">				.checkArgument(</span>
<span class="fc" id="L338">						this.claim.getStates().contains(claimState),</span>
<span class="fc" id="L339">						&quot;The state &quot;</span>
<span class="fc" id="L340">								+ claimState</span>
<span class="fc" id="L341">								+ &quot; is not contained into the set of the states of the claim&quot;);</span>
		Preconditions
<span class="fc" id="L343">				.checkArgument(</span>
<span class="fc" id="L344">						this.model.getStates().contains(modelState),</span>
<span class="fc" id="L345">						&quot;The state &quot;</span>
<span class="fc" id="L346">								+ modelState</span>
<span class="fc" id="L347">								+ &quot; is not contained into the set of the states of the model&quot;);</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">		if (!createdStates.containsKey(modelState)) {</span>
<span class="fc" id="L349">			return new HashSet&lt;State&gt;();</span>
		} else {
<span class="fc bfc" id="L351" title="All 2 branches covered.">			if (!createdStates.get(modelState).containsKey(claimState)) {</span>
<span class="fc" id="L352">				return new HashSet&lt;State&gt;();</span>
			} else {
<span class="fc" id="L354">				return Collections</span>
<span class="fc" id="L355">						.unmodifiableSet(new HashSet&lt;State&gt;(createdStates</span>
<span class="fc" id="L356">								.get(modelState).get(claimState).values()));</span>
			}
		}
	}

	/**
	 * returns the intersection state (if it exists) that is associated with the
	 * specified model state, the claim state and the number passed as parameter
	 * 
	 * @param modelState
	 *            is the state of the model to be considered
	 * @param claimState
	 *            the state of the claim under analysis
	 * @param number
	 *            the number to be considered
	 * @return the intersection state associated with the inputs, null if such a
	 *         state does not exist
	 * @throws NullPointerException
	 *             if the model state or the claim state is null
	 * @throws IllegalArgumentException
	 *             if the modelState or the claimState is not a state of the
	 *             model or the claim or if no state is associated with the
	 *             model state, claim state and number
	 * @throws IllegalStateException
	 *             if the intersection has still to be computed
	 */
	public State getIntersectionState(State modelState, State claimState,
			int number) {
<span class="fc" id="L384">		Preconditions.checkState(this.isPerformed(),</span>
<span class="fc" id="L385">				&quot;The intersection has still not be computed&quot;);</span>

<span class="fc" id="L387">		Preconditions.checkNotNull(claimState,</span>
<span class="fc" id="L388">				&quot;The state of the claim cannot be null&quot;);</span>
<span class="fc" id="L389">		Preconditions.checkNotNull(modelState,</span>
<span class="fc" id="L390">				&quot;The state of the model cannot be null&quot;);</span>
		Preconditions
<span class="fc" id="L392">				.checkArgument(</span>
<span class="fc" id="L393">						this.claim.getStates().contains(claimState),</span>
<span class="fc" id="L394">						&quot;The state &quot;</span>
<span class="fc" id="L395">								+ claimState</span>
<span class="fc" id="L396">								+ &quot; is not contained into the set of the states of the claim&quot;);</span>
		Preconditions
<span class="fc" id="L398">				.checkArgument(</span>
<span class="fc" id="L399">						this.model.getStates().contains(modelState),</span>
<span class="fc" id="L400">						&quot;The state &quot;</span>
<span class="fc" id="L401">								+ modelState</span>
<span class="fc" id="L402">								+ &quot; is not contained into the set of the states of the model&quot;);</span>
<span class="fc bfc" id="L403" title="All 4 branches covered.">		Preconditions.checkArgument(number &gt;= 0 &amp;&amp; number &lt;= 2,</span>
<span class="fc" id="L404">				&quot;The number must be between 0 and 2&quot;);</span>

<span class="fc bfc" id="L406" title="All 2 branches covered.">		if (!createdStates.containsKey(modelState)) {</span>
<span class="fc" id="L407">			return null;</span>
		} else {
<span class="fc bfc" id="L409" title="All 2 branches covered.">			if (!createdStates.get(modelState).containsKey(claimState)) {</span>
<span class="fc" id="L410">				return null;</span>
			} else {
<span class="fc" id="L412">				if (!createdStates.get(modelState).get(claimState)</span>
<span class="fc bfc" id="L413" title="All 2 branches covered.">						.containsKey(number)) {</span>
<span class="fc" id="L414">					return null;</span>
				}
<span class="fc" id="L416">				return createdStates.get(modelState).get(claimState)</span>
<span class="fc" id="L417">						.get(number);</span>
			}
		}
	}

	/**
	 * returns the set of constrained transitions associated with the black box
	 * state
	 * 
	 * @param blackBoxState
	 *            is the black box state of the model to be considered
	 * @return the set of transition associated with the black box state
	 * @throws NullPointerException
	 *             if the black box state is null
	 * @throws IllegalArgumentException
	 *             if the black box state is not a black box state of the model
	 * @throws IllegalStateException
	 *             if the intersection has still to be computed
	 */
	public Set&lt;Transition&gt; getConstrainedTransitions(State blackBoxState) {
<span class="fc" id="L437">		Preconditions.checkState(this.isPerformed(),</span>
<span class="fc" id="L438">				&quot;The intersection has still not be computed&quot;);</span>
<span class="fc" id="L439">		Preconditions.checkNotNull(blackBoxState,</span>
<span class="fc" id="L440">				&quot;The black box state to be considered cannot be null&quot;);</span>
<span class="fc" id="L441">		Preconditions.checkArgument(</span>
<span class="fc" id="L442">				this.model.getBlackBoxStates().contains(blackBoxState),</span>
<span class="fc" id="L443">				&quot;The state &quot; + blackBoxState + &quot; is not black box&quot;);</span>

<span class="fc" id="L445">		return this.mapBlackBoxStateConstrainedTransition.get(blackBoxState);</span>
	}

	/**
	 * returns the set of the states of the intersection which are associated
	 * with a specific state of the claim
	 * 
	 * @param claimState
	 *            is the state of the claim under interest
	 * @return the set of the states of the intersection automaton associated
	 *         with the claim state
	 * @throws NullPointerException
	 *             if the claim state is null
	 * @throws IllegalArgumentException
	 *             if the claimState is not a state of the claim
	 * @throws IllegalStateException
	 *             if the intersection has still to be computed
	 */
	public Set&lt;State&gt; getClaimIntersectionStates(State claimState) {
<span class="fc" id="L464">		Preconditions.checkState(this.isPerformed(),</span>
<span class="fc" id="L465">				&quot;The intersection has still not be computed&quot;);</span>
<span class="fc" id="L466">		Preconditions.checkNotNull(claimState,</span>
<span class="fc" id="L467">				&quot;The state of the claim cannot be null&quot;);</span>
		Preconditions
<span class="fc" id="L469">				.checkArgument(</span>
<span class="fc" id="L470">						this.claim.getStates().contains(claimState),</span>
<span class="fc" id="L471">						&quot;The state &quot;</span>
<span class="fc" id="L472">								+ claimState</span>
<span class="fc" id="L473">								+ &quot; is not contained into the set of the states of the claim&quot;);</span>
<span class="fc" id="L474">		return this.claimStateintersectionStateMap.get(claimState);</span>
	}

	/**
	 * returns the set of the states of the intersection which are associated
	 * with a specific state of the model
	 * 
	 * @param modelState
	 *            is the state of the model under interest
	 * @return the set of the states of the intersection automaton associated
	 *         with the model state
	 * @throws NullPointerException
	 *             if the model state is null
	 * @throws IllegalArgumentException
	 *             if the modelState is not a state of the model
	 * @throws IllegalStateException
	 *             if the intersection has still to be computed
	 */
	public Set&lt;State&gt; getModelIntersectionStates(State modelState) {
<span class="fc" id="L493">		Preconditions.checkState(this.isPerformed(),</span>
<span class="fc" id="L494">				&quot;The intersection has still not be computed&quot;);</span>
		Preconditions
<span class="fc" id="L496">				.checkNotNull(modelState, &quot;The model state cannot be null&quot;);</span>

		Preconditions
<span class="fc" id="L499">				.checkArgument(</span>
<span class="fc" id="L500">						this.model.getStates().contains(modelState),</span>
<span class="fc" id="L501">						&quot;The state &quot;</span>
<span class="fc" id="L502">								+ modelState</span>
<span class="fc" id="L503">								+ &quot; is not contained into the set of the states of the model&quot;);</span>
<span class="fc" id="L504">		return this.modelStateintersectionStateMap.get(modelState);</span>
	}

	/**
	 * returns the intersection automaton
	 * 
	 * @return the intersection automaton which have been computed
	 * @throws IllegalStateException
	 *             if the intersection has still to be computed
	 */
	public IntersectionBA getIntersectionAutomaton() {
		Preconditions
<span class="fc" id="L516">				.checkState(</span>
<span class="fc" id="L517">						this.isPerformed(),</span>
<span class="fc" id="L518">						&quot;it is necessary to compute the intersection before returning the intersection automaton&quot;);</span>
<span class="fc" id="L519">		return this.intersection;</span>

	}

	/**
	 * returns the model state associated with the specified intersection state
	 * 
	 * @param intersectionState
	 *            the intersection state to be considered
	 * @return the state of the model associated with the specified
	 *         intersections state
	 * @throws NullPointerException
	 *             if the intersection states is null
	 * @throws IllegalArgumentException
	 *             if the intersection state is not contained into the set of
	 *             the states of the intersection automaton
	 */
	public State getModelState(State intersectionState) {
<span class="fc" id="L537">		Preconditions.checkNotNull(intersectionState,</span>
<span class="fc" id="L538">				&quot;The intersection state to be considered cannot be null&quot;);</span>
		Preconditions
<span class="fc" id="L540">				.checkArgument(</span>
<span class="fc" id="L541">						this.intersection.getStates().contains(</span>
<span class="fc" id="L542">								intersectionState),</span>
<span class="fc" id="L543">						&quot;The intersection state is not present in the set of the states of the intersection automaton&quot;);</span>
<span class="fc" id="L544">		return intersectionStateModelStateMap.get(intersectionState);</span>
	}

	/**
	 * returns the claim state associated with the specified intersection state
	 * 
	 * @param intersectionState
	 *            the intersection state to be considered
	 * @return the state of the claim associated with the specified
	 *         intersections state
	 * @throws NullPointerException
	 *             if the intersection states is null
	 * @throws IllegalArgumentException
	 *             if the intersection state is not contained into the set of
	 *             the states of the intersection automaton
	 */
	public State getClaimState(State intersectionState) {
<span class="fc" id="L561">		Preconditions.checkNotNull(intersectionState,</span>
<span class="fc" id="L562">				&quot;The intersection state to be considered cannot be null&quot;);</span>
		Preconditions
<span class="fc" id="L564">				.checkArgument(</span>
<span class="fc" id="L565">						this.intersection.getStates().contains(</span>
<span class="fc" id="L566">								intersectionState),</span>
<span class="fc" id="L567">						&quot;The intersection state is not present in the set of the states of the intersection automaton&quot;);</span>
<span class="fc" id="L568">		return this.intersectionStateClaimStateMap.get(intersectionState);</span>
	}

	/**
	 * returns the accepting policy used to compute the intersection
	 * 
	 * @return the accepting policy used to compute the intersection
	 */
	public AcceptingPolicy getAcceptingPolicy() {
<span class="fc" id="L577">		return this.acceptingPolicy;</span>
	}

	/**
	 * returns the model from which the intersection is computed
	 * 
	 * @return the model from which the intersection is computed
	 */
	public IBA getModel() {
<span class="fc" id="L586">		return this.model;</span>
	}

	/**
	 * contains the claim from which the intersection is computed
	 * 
	 * @return the claim from which the intersection is computed
	 */
	public BA getClaim() {

<span class="fc" id="L596">		return this.claim;</span>
	}

	/**
	 * given an intersectionState returns the corresponding number
	 * 
	 * @param intersectionState
	 *            is the intersection state of interest
	 * @return the number of the intersection state
	 * @throws NullPointerException
	 *             if the intersectionState is null
	 * @throws IllegalArgumentException
	 *             if the intersection state is not contained into the set of
	 *             the states of the intersection
	 */
	public int getNumber(State intersectionState) {
<span class="fc" id="L612">		Preconditions.checkNotNull(intersectionState,</span>
<span class="fc" id="L613">				&quot;The state cannot be null&quot;);</span>
		Preconditions
<span class="fc" id="L615">				.checkArgument(</span>
<span class="fc" id="L616">						this.intersection.getStates().contains(</span>
<span class="fc" id="L617">								intersectionState),</span>
<span class="fc" id="L618">						&quot;The state &quot;</span>
<span class="fc" id="L619">								+ intersectionState</span>
<span class="fc" id="L620">								+ &quot; is not contained into the set of the states of the intersection&quot;);</span>

<span class="fc" id="L622">		return this.intersectionStateNumber.get(intersectionState);</span>
	}

	/**
	 * checks if a state has been already been visited in the intersection
	 * generation
	 * 
	 * @param modelState
	 *            is the state of the model to be considered
	 * @param claimState
	 *            is the state of the claim to be considered
	 * @param number
	 *            is the number of the intersection state
	 * @return true if the state has been already visited, false otherwise
	 */
	private boolean checkVisitedStates(State modelState, State claimState,
			int number) {
		Preconditions
<span class="fc" id="L640">				.checkNotNull(modelState, &quot;The model state cannot be null&quot;);</span>
<span class="fc" id="L641">		Preconditions.checkNotNull(claim, &quot;The claim state cannot be null&quot;);</span>

<span class="fc" id="L643">		return this.visitedStates</span>
<span class="fc" id="L644">				.contains(new ImmutableTriple&lt;State, State, Integer&gt;(</span>
<span class="fc" id="L645">						modelState, claimState, number));</span>
	}

	/**
	 * is a recursive procedure that computes the intersection of this automaton
	 * and the automaton a2
	 * 
	 * @param modelState
	 *            is the current state of the model under analysis
	 * @param claimState
	 *            is the current state of the claim under analysis
	 * @param number
	 *            is the number of the state under analysis
	 * @return the state that is generated
	 */
	private State computeIntersection(State modelState, State claimState,
			int number) {
		Preconditions
<span class="fc" id="L663">				.checkArgument(this.model.getStates().contains(modelState));</span>
		Preconditions
<span class="fc" id="L665">				.checkArgument(this.claim.getStates().contains(claimState));</span>

		// if the state has been already been visited
<span class="fc bfc" id="L668" title="All 2 branches covered.">		if (this.checkVisitedStates(modelState, claimState, number)) {</span>
<span class="fc" id="L669">			return this.createdStates.get(modelState).get(claimState)</span>
<span class="fc" id="L670">					.get(number);</span>
		} else {

<span class="fc" id="L673">			State intersectionState = this.intersectionStateFactory.create(</span>
<span class="fc" id="L674">					modelState, claimState, number);</span>
<span class="fc" id="L675">			this.addStateIntoTheIntersectionAutomaton(intersectionState,</span>
<span class="fc" id="L676">					modelState, claimState, number);</span>
<span class="fc" id="L677">			this.updateVisitedStates(intersectionState, modelState, claimState,</span>
<span class="fc" id="L678">					number);</span>

			// for each transition in the automaton that exits the model state
<span class="fc bfc" id="L681" title="All 2 branches covered.">			for (Transition modelTransition : model</span>
<span class="fc" id="L682">					.getOutTransitions(modelState)) {</span>
				// for each transition in the extended automaton whit exit the
				// claim
				// state
<span class="fc bfc" id="L686" title="All 2 branches covered.">				for (Transition claimTransition : claim</span>
<span class="fc" id="L687">						.getOutTransitions(claimState)) {</span>

					// if the two transitions are compatible
<span class="fc" id="L690">					if (this.intersectionTransitionBuilder.isCompatible(</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">							modelTransition, claimTransition)) {</span>

						// creates a new state made by the states s1next and s2
						// next
<span class="fc" id="L695">						State nextModelState = model</span>
<span class="fc" id="L696">								.getTransitionDestination(modelTransition);</span>
<span class="fc" id="L697">						State nextClaimState = claim</span>
<span class="fc" id="L698">								.getTransitionDestination(claimTransition);</span>

<span class="fc" id="L700">						int nextNumber = this.acceptingPolicy.comuteNumber(</span>
<span class="fc" id="L701">								nextModelState, nextClaimState, number);</span>

<span class="fc" id="L703">						State nextState = this.computeIntersection(</span>
<span class="fc" id="L704">								nextModelState, nextClaimState, nextNumber);</span>

<span class="fc" id="L706">						Transition t = this.intersectionTransitionBuilder</span>
<span class="fc" id="L707">								.getIntersectionTransition(modelTransition,</span>
<span class="fc" id="L708">										claimTransition);</span>
<span class="fc" id="L709">						this.intersection.addTransition(intersectionState,</span>
<span class="fc" id="L710">								nextState, t);</span>
					}
				}
			}

			// if the current state of the extended automaton is black box state
<span class="fc bfc" id="L716" title="All 2 branches covered.">			if (model.isBlackBox(modelState)) {</span>
				// for each transition in the automaton a2
<span class="fc bfc" id="L718" title="All 2 branches covered.">				for (Transition claimTransition : claim</span>
<span class="fc" id="L719">						.getOutTransitions(claimState)) {</span>

<span class="fc" id="L721">					State nextClaimState = claim</span>
<span class="fc" id="L722">							.getTransitionDestination(claimTransition);</span>

<span class="fc" id="L724">					int nextNumber = this.acceptingPolicy.comuteNumber(</span>
<span class="fc" id="L725">							modelState, nextClaimState, number);</span>

<span class="fc" id="L727">					State nextState = this.computeIntersection(modelState,</span>
<span class="fc" id="L728">							nextClaimState, nextNumber);</span>

<span class="fc" id="L730">					Transition intersectionTransition = new ClaimTransitionFactory()</span>
<span class="fc" id="L731">							.create(claimTransition.getPropositions());</span>

<span class="fc" id="L733">					this.intersection.addConstrainedTransition(</span>
<span class="fc" id="L734">							intersectionState, nextState,</span>
<span class="fc" id="L735">							intersectionTransition);</span>

<span class="fc" id="L737">					this.mapConstrainedTransitionModelBlackBoxState.put(</span>
<span class="fc" id="L738">							intersectionTransition, modelState);</span>

				}
			}
<span class="fc" id="L742">			return intersectionState;</span>
		}
	}

	private void updateVisitedStates(State intersectionState, State modelState,
			State claimState, int number) {
		Preconditions
<span class="fc" id="L749">				.checkNotNull(modelState, &quot;The model state cannot be null&quot;);</span>
<span class="fc" id="L750">		Preconditions.checkNotNull(claim, &quot;The claim state cannot be null&quot;);</span>
<span class="fc" id="L751">		this.visitedStates.add(new ImmutableTriple&lt;State, State, Integer&gt;(</span>
<span class="fc" id="L752">				modelState, claimState, number));</span>

<span class="fc bfc" id="L754" title="All 2 branches covered.">		if (!this.createdStates.containsKey(modelState)) {</span>
<span class="fc" id="L755">			Map&lt;State, Map&lt;Integer, State&gt;&gt; map1 = new HashMap&lt;State, Map&lt;Integer, State&gt;&gt;();</span>
<span class="fc" id="L756">			Map&lt;Integer, State&gt; map2 = new HashMap&lt;Integer, State&gt;();</span>
<span class="fc" id="L757">			map2.put(number, intersectionState);</span>
<span class="fc" id="L758">			map1.put(claimState, map2);</span>
<span class="fc" id="L759">			this.createdStates.put(modelState, map1);</span>

<span class="fc" id="L761">		} else {</span>
<span class="fc bfc" id="L762" title="All 2 branches covered.">			if (!this.createdStates.get(modelState).containsKey(claimState)) {</span>
<span class="fc" id="L763">				Map&lt;Integer, State&gt; map2 = new HashMap&lt;Integer, State&gt;();</span>
<span class="fc" id="L764">				map2.put(number, intersectionState);</span>
<span class="fc" id="L765">				this.createdStates.get(modelState).put(claimState, map2);</span>
<span class="fc" id="L766">			} else {</span>
<span class="fc" id="L767">				if (!this.createdStates.get(modelState).get(claimState)</span>
<span class="pc bpc" id="L768" title="1 of 2 branches missed.">						.containsKey(new Integer(number))) {</span>
<span class="fc" id="L769">					this.createdStates.get(modelState).get(claimState)</span>
<span class="fc" id="L770">							.put(new Integer(number), intersectionState);</span>
				}
			}
		}

<span class="fc" id="L775">		this.intersectionStateModelStateMap.put(intersectionState, modelState);</span>
<span class="fc" id="L776">		this.intersectionStateClaimStateMap.put(intersectionState, claimState);</span>
<span class="fc" id="L777">	}</span>

	/**
	 * adds the intersection state to the intersection automaton
	 * 
	 * @param intersectionState
	 *            the intersection state to be added
	 * @param modelState
	 *            the state of the model that corresponds to the intersection
	 *            state
	 * @param claimState
	 *            the state of the claim that corresponds to the intersection
	 *            state
	 * @param number
	 *            the number associated with the intersection state
	 */
	private void addStateIntoTheIntersectionAutomaton(State intersectionState,
			State modelState, State claimState, int number) {
<span class="fc" id="L795">		this.intersectionStateNumber.put(intersectionState, number);</span>
<span class="fc" id="L796">		this.intersection.addState(intersectionState);</span>
<span class="fc bfc" id="L797" title="All 2 branches covered.">		if (this.model.getInitialStates().contains(modelState)</span>
<span class="pc bpc" id="L798" title="1 of 2 branches missed.">				&amp;&amp; this.claim.getInitialStates().contains(claimState)) {</span>
<span class="pc bpc" id="L799" title="1 of 2 branches missed.">			if (this.acceptingPolicy instanceof KripkeAcceptingPolicy) {</span>
<span class="nc" id="L800">				this.intersection.addInitialState(intersectionState);</span>
<span class="nc" id="L801">			} else {</span>
<span class="pc bpc" id="L802" title="1 of 2 branches missed.">				if (number == 0) {</span>
<span class="fc" id="L803">					this.intersection.addInitialState(intersectionState);</span>
				}
			}

		}
<span class="fc bfc" id="L808" title="All 2 branches covered.">		if (number == 2) {</span>
<span class="fc" id="L809">			this.intersection.addAcceptState(intersectionState);</span>
		}
<span class="fc bfc" id="L811" title="All 2 branches covered.">		if (this.model.isBlackBox(modelState)) {</span>
<span class="fc" id="L812">			this.intersection.addMixedState(intersectionState);</span>
		}
<span class="fc" id="L814">	}</span>

	/**
	 * updates the alphabet of the automaton by adding the set of the
	 * propositions of the model and the claim
	 */
	private void updateAlphabet() {
<span class="fc" id="L821">		this.intersection.addPropositions(this.model.getPropositions());</span>
<span class="fc" id="L822">		this.intersection.addPropositions(this.claim.getPropositions());</span>
<span class="fc" id="L823">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>
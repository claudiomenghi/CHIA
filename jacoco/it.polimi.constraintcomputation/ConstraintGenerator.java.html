<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="it"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ConstraintGenerator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CHIAContraintComputation</a> &gt; <a href="index.source.html" class="el_package">it.polimi.constraintcomputation</a> &gt; <span class="el_source">ConstraintGenerator.java</span></div><h1>ConstraintGenerator.java</h1><pre class="source lang-java linenums">package it.polimi.constraintcomputation;

import it.polimi.action.CHIAAction;
import it.polimi.automata.IBA;
import it.polimi.automata.state.State;
import it.polimi.checker.Checker;
import it.polimi.checker.SatisfactionValue;
import it.polimi.constraintcomputation.cleaner.AutomatonCleaner;
import it.polimi.constraintcomputation.reachability.ReachabilityIdentifier;
import it.polimi.constraintcomputation.subpropertyidentifier.SubPropertyIdentifier;
import it.polimi.constraintcomputation.subpropertyidentifier.labeling.TransitionLabeler;
import it.polimi.constraints.Constraint;
import it.polimi.constraints.components.SubProperty;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;


import org.apache.log4j.Logger;

import com.google.common.base.Preconditions;

/**
 * The constraint generator computes a constraint. A constraint specifies the
 * conditions the behavior if the replacement of the black box state must
 * satisfy
 * 
 * @author Claudio Menghi
 * 
 */
public class ConstraintGenerator extends CHIAAction&lt;Constraint&gt; {

    /**
     * The name of the constraint computation activity
     */
    private final static String NAME = &quot;CONSTRAINT GENERATION&quot;;

    /**
     * the checker using to verify the incomplete model against the property of
     * interest
     */
    private final Checker checker;

    /**
     * the constraint generated
     */
    private final Constraint constraint;

    /**
     * contains the CHIA logger
     */
<span class="fc" id="L53">    private static final Logger LOGGER = Logger</span>
<span class="fc" id="L54">            .getLogger(ConstraintGenerator.class);</span>

    /**
     * is a map that contains for each sub-property the identifier used to
     * compute the sub-property
     */
    private final Map&lt;SubProperty, SubPropertyIdentifier&gt; subpropetySubPropertyIdentifierMap;

    /**
     * maps each black box state to the corresponding sub-property
     */
    private final Map&lt;State, SubProperty&gt; mapBlackBoxStateSubProperty;

    /**
     * maps each black box state to the identifier used to compute the
     * sub-property
     */
    private final Map&lt;State, SubPropertyIdentifier&gt; mapBlackBoxStateSubPropertyIdentifier;

    /**
     * creates a new ConstraintGenerator object which starting from the checker
     * used to verify the property of interest over the incomplete model
     * 
     * @param checker
     *            is the model checker
     * @throws NullPointerException
     *             if one of the parameters is null
     * @throws IllegalStateException
     *             if the checker has not been executed before the constraint
     *             generation
     */
    public ConstraintGenerator(Checker checker) {
<span class="fc" id="L86">        super(NAME);</span>
<span class="fc" id="L87">        Preconditions.checkNotNull(checker, &quot;The checker cannot be null&quot;);</span>
<span class="fc" id="L88">        Preconditions</span>
<span class="fc" id="L89">                .checkState(</span>
<span class="fc bfc" id="L90" title="All 2 branches covered.">                        checker.perform() == SatisfactionValue.POSSIBLYSATISFIED,</span>
                        &quot;You can perform the constraint generation iff the claim is possibly satisfied&quot;);

<span class="fc" id="L93">        this.checker = checker;</span>
<span class="fc" id="L94">        this.constraint = new Constraint();</span>
<span class="fc" id="L95">        this.subpropetySubPropertyIdentifierMap = new HashMap&lt;SubProperty, SubPropertyIdentifier&gt;();</span>
<span class="fc" id="L96">        this.mapBlackBoxStateSubProperty = new HashMap&lt;State, SubProperty&gt;();</span>
<span class="fc" id="L97">        this.mapBlackBoxStateSubPropertyIdentifier = new HashMap&lt;State, SubPropertyIdentifier&gt;();</span>
<span class="fc" id="L98">    }</span>

    /**
     * returns the constraint associated with the black box states
     * 
     * @return the constraint associated with the black box states
     */
    @Override
    public Constraint perform() {

<span class="fc" id="L108">        this.cleanIntersectionAutomaton();</span>

<span class="fc bfc" id="L110" title="All 2 branches covered.">        for (State blackBoxState : this.checker.getUpperIntersectionBuilder()</span>
<span class="fc" id="L111">                .getModel().getBlackBoxStates()) {</span>

<span class="fc" id="L113">            LOGGER.debug(&quot;Computing the sub-property for the blak box state:&quot;</span>
                    + blackBoxState);
<span class="fc" id="L115">            constraint.addSubProperty(this.generateSubProperty(blackBoxState));</span>

<span class="fc" id="L117">        }</span>

<span class="fc" id="L119">        LOGGER.debug(&quot;Intersection cleaned&quot;);</span>
<span class="fc" id="L120">        LOGGER.debug(&quot;Automaton size: &quot;</span>
<span class="fc" id="L121">                + this.checker.getUpperIntersectionBuilder().perform().size());</span>
<span class="fc" id="L122">        this.computeLabels();</span>

<span class="fc" id="L124">        LOGGER.debug(&quot;Labels of the incoming and outgoing transitions computed&quot;);</span>
<span class="fc" id="L125">        LOGGER.debug(&quot;Computing the incoming and outgoing transitions reachability&quot;);</span>
<span class="fc" id="L126">        this.computeTransitionReachability();</span>
<span class="fc" id="L127">        LOGGER.debug(&quot;Incoming and outgoing transitions reachability computed&quot;);</span>
<span class="fc" id="L128">        this.computeIndispensable();</span>
<span class="fc" id="L129">        return constraint;</span>

    }

	private void cleanIntersectionAutomaton() {
<span class="fc" id="L134">		LOGGER.debug(&quot;starting the cleaning phase&quot;);</span>
        /*
         * computes the states of the intersection automaton from which it is
         * not possible to reach an accepting state since these states are not
         * useful in the constraint computation
         */
<span class="fc" id="L140">        AutomatonCleaner intersectionCleaner = new AutomatonCleaner(</span>
<span class="fc" id="L141">                this.checker.getUpperIntersectionBuilder()</span>
<span class="fc" id="L142">                        .getIntersectionAutomaton());</span>
<span class="fc" id="L143">        Set&lt;State&gt; removedStates = intersectionCleaner.clean();</span>

<span class="fc" id="L145">        LOGGER.debug(&quot;The Automaton cleaner has removed: &quot;</span>
<span class="fc" id="L146">                + removedStates.size());</span>

        // removing the removed states from the intersection and the
        // intersection builder
<span class="fc bfc" id="L150" title="All 2 branches covered.">        for (State s : removedStates) {</span>
<span class="fc" id="L151">            this.checker.getUpperIntersectionBuilder().removeIntersectionState(</span>
                    s);
<span class="fc" id="L153">        }</span>
<span class="fc" id="L154">	}</span>

    /**
     * computes the constraint considering only the specific black box state
     * 
     * @param blackBoxState
     *            the black box state to be considered
     * @return the constraint containing only the sub-property associated with
     *         the black box state
     * @throws NullPointerException
     *             if the black box state is null
     */
    public Constraint perform(State blackBoxState) {
<span class="fc" id="L167">        Preconditions.checkNotNull(blackBoxState,</span>
                &quot;The black box state to be considered cannot be null&quot;);
<span class="fc" id="L169">        cleanIntersectionAutomaton();</span>

<span class="fc" id="L171">        LOGGER.debug(&quot;Computing the sub-property for the blak box state:&quot;</span>
                + blackBoxState);
<span class="fc" id="L173">        constraint.addSubProperty(this.generateSubProperty(blackBoxState));</span>

<span class="fc" id="L175">        LOGGER.debug(&quot;Intersection cleaned&quot;);</span>
<span class="fc" id="L176">        LOGGER.debug(&quot;Automaton size: &quot;</span>
<span class="fc" id="L177">                + this.checker.getUpperIntersectionBuilder().perform().size());</span>
<span class="fc" id="L178">        this.computeLabels(blackBoxState);</span>

<span class="fc" id="L180">        LOGGER.debug(&quot;Labels of the incoming and outgoing transitions computed&quot;);</span>
<span class="fc" id="L181">        LOGGER.debug(&quot;Computing the incoming and outgoing transitions reachability&quot;);</span>
<span class="fc" id="L182">        this.computeTransitionReachability(blackBoxState);</span>
<span class="fc" id="L183">        LOGGER.debug(&quot;Incoming and outgoing transitions reachability computed&quot;);</span>
<span class="fc" id="L184">        this.computeIndispensable(blackBoxState);</span>
<span class="fc" id="L185">        return constraint;</span>

    }

    /**
     * returns the sub-property associated with the specific black box state
     * 
     * @param blackBoxState
     *            the black box state to be considered
     * @return the sub-property associated with the black box state
     * @throws NullPointerException
     *             if the black box state is null
     */
    private SubProperty generateSubProperty(State blackBoxState) {

        /*
         * extract the sub-properties from the intersection automaton. It
         * identifies the portions of the state space (the set of the mixed
         * states and the transitions between them) that refer to the same black
         * box states of the model. It also compute the corresponding ports,
         * i.e., the set of the transition that connect the sub-property to the
         * original model.
         */
<span class="fc" id="L208">        SubPropertyIdentifier subPropertiesIdentifier = new SubPropertyIdentifier(</span>
                this.checker, blackBoxState);
<span class="fc" id="L210">        SubProperty subProperty = subPropertiesIdentifier.perform();</span>
<span class="fc" id="L211">        this.subpropetySubPropertyIdentifierMap.put(subProperty,</span>
                subPropertiesIdentifier);
<span class="fc" id="L213">        this.mapBlackBoxStateSubProperty.put(blackBoxState, subProperty);</span>
<span class="fc" id="L214">        this.mapBlackBoxStateSubPropertyIdentifier.put(blackBoxState,</span>
                subPropertiesIdentifier);
<span class="fc" id="L216">        return subProperty;</span>
    }

    private void computeLabels(State blackBoxState) {

<span class="fc" id="L221">        Preconditions.checkNotNull(blackBoxState,</span>
                &quot;The black box state cannot be null&quot;);
<span class="fc" id="L223">        Preconditions.checkArgument(</span>
<span class="fc" id="L224">                this.mapBlackBoxStateSubProperty.containsKey(blackBoxState),</span>
                &quot;The black box state &quot; + blackBoxState
                        + &quot; is not contained in the map&quot;);
<span class="fc" id="L227">        TransitionLabeler labeler = new TransitionLabeler(</span>
<span class="fc" id="L228">                this.mapBlackBoxStateSubPropertyIdentifier.get(blackBoxState));</span>
<span class="fc" id="L229">        labeler.perform();</span>

<span class="fc" id="L231">    }</span>

    /**
     * computes the labels associated with the different black box states
     */
    private void computeLabels() {

<span class="fc bfc" id="L238" title="All 2 branches covered.">        for (java.util.Map.Entry&lt;SubProperty, SubPropertyIdentifier&gt; entry : this.subpropetySubPropertyIdentifierMap</span>
<span class="fc" id="L239">                .entrySet()) {</span>
<span class="fc" id="L240">            TransitionLabeler labeler = new TransitionLabeler(entry.getValue());</span>
<span class="fc" id="L241">            labeler.perform();</span>
<span class="fc" id="L242">        }</span>
<span class="fc" id="L243">    }</span>

    /**
     * computes the reachability between the ports, i.e., it updates the
     * reachability relation between the ports and updates the corresponding
     * colors
     * 
     * @return the constraints where the color of the ports have been updated
     */
    private Constraint computeTransitionReachability() {

<span class="fc bfc" id="L254" title="All 2 branches covered.">        for (Map.Entry&lt;SubProperty, SubPropertyIdentifier&gt; e : subpropetySubPropertyIdentifierMap</span>
<span class="fc" id="L255">                .entrySet()) {</span>
<span class="fc" id="L256">            LOGGER.debug(&quot;Computing the reachability of the sub-property: &quot;</span>
<span class="fc" id="L257">                    + e.getKey().getModelState());</span>
            
<span class="fc" id="L259">            ReachabilityIdentifier reachability = new ReachabilityIdentifier(</span>
<span class="fc" id="L260">                    e.getValue());</span>
<span class="fc" id="L261">            reachability.perform();</span>

<span class="fc" id="L263">        }</span>

<span class="fc" id="L265">        return constraint;</span>

    }

    private Constraint computeTransitionReachability(State blackBoxState) {

<span class="fc" id="L271">        Preconditions.checkNotNull(blackBoxState,</span>
                &quot;The black box state cannot be null&quot;);
<span class="fc" id="L273">        Preconditions.checkArgument(this.mapBlackBoxStateSubPropertyIdentifier</span>
<span class="fc" id="L274">                .containsKey(blackBoxState), &quot;The black box state &quot;</span>
                + blackBoxState + &quot; is not contained in the map&quot;);
<span class="fc" id="L276">        ReachabilityIdentifier reachability = new ReachabilityIdentifier(</span>
<span class="fc" id="L277">                this.mapBlackBoxStateSubPropertyIdentifier.get(blackBoxState));</span>
<span class="fc" id="L278">        reachability.perform();</span>

<span class="fc" id="L280">        return constraint;</span>

    }

    private void computeIndispensable(State blackBoxState) {
<span class="fc" id="L285">        Preconditions.checkNotNull(blackBoxState,</span>
                &quot;The black box state cannot be null&quot;);
<span class="fc" id="L287">        Preconditions.checkArgument(</span>
<span class="fc" id="L288">                this.mapBlackBoxStateSubProperty.containsKey(blackBoxState),</span>
                &quot;The black box state &quot; + blackBoxState
                        + &quot; is not contained in the map&quot;);
<span class="fc" id="L291">        SubProperty subProperty = this.mapBlackBoxStateSubProperty</span>
<span class="fc" id="L292">                .get(blackBoxState);</span>
<span class="fc" id="L293">        State modelState = subProperty.getModelState();</span>
<span class="fc" id="L294">        IBA model = checker.getUpperIntersectionBuilder().getModel().clone();</span>
<span class="fc" id="L295">        model.removeState(modelState);</span>
<span class="fc" id="L296">        SatisfactionValue value = new Checker(model, checker</span>
<span class="fc" id="L297">                .getUpperIntersectionBuilder().getClaim(), checker</span>
<span class="fc" id="L298">                .getUpperIntersectionBuilder().getAcceptingPolicy()).perform();</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if (value == SatisfactionValue.NOTSATISFIED) {</span>
<span class="nc" id="L300">            throw new InternalError(</span>
                    &quot;It is not possible that removing a black box state of the model makes the property not satisfied&quot;);
        }
<span class="fc bfc" id="L303" title="All 2 branches covered.">        if (value == SatisfactionValue.POSSIBLYSATISFIED) {</span>
<span class="fc" id="L304">            subProperty.setIndispensable(false);</span>
        }
<span class="fc bfc" id="L306" title="All 2 branches covered.">        if (value == SatisfactionValue.SATISFIED) {</span>
<span class="fc" id="L307">            subProperty.setIndispensable(true);</span>
        }

<span class="fc" id="L310">    }</span>

    private void computeIndispensable() {
<span class="fc bfc" id="L313" title="All 2 branches covered.">        for (java.util.Map.Entry&lt;SubProperty, SubPropertyIdentifier&gt; entry : this.subpropetySubPropertyIdentifierMap</span>
<span class="fc" id="L314">                .entrySet()) {</span>
<span class="fc" id="L315">            State modelState = entry.getKey().getModelState();</span>
<span class="fc" id="L316">            IBA model = checker.getUpperIntersectionBuilder().getModel()</span>
<span class="fc" id="L317">                    .clone();</span>
<span class="fc" id="L318">            model.removeState(modelState);</span>
<span class="fc" id="L319">            SatisfactionValue value = new Checker(model, checker</span>
<span class="fc" id="L320">                    .getUpperIntersectionBuilder().getClaim(), checker</span>
<span class="fc" id="L321">                    .getUpperIntersectionBuilder().getAcceptingPolicy())</span>
<span class="fc" id="L322">                    .perform();</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">            if (value == SatisfactionValue.NOTSATISFIED) {</span>
<span class="nc" id="L324">                throw new InternalError(</span>
                        &quot;It is not possible that removing a black box state of the model makes the property not satisfied&quot;);
            }
<span class="fc bfc" id="L327" title="All 2 branches covered.">            if (value == SatisfactionValue.POSSIBLYSATISFIED) {</span>
<span class="fc" id="L328">                entry.getKey().setIndispensable(false);</span>
            }
<span class="fc bfc" id="L330" title="All 2 branches covered.">            if (value == SatisfactionValue.SATISFIED) {</span>
<span class="fc" id="L331">                entry.getKey().setIndispensable(true);</span>
            }
<span class="fc" id="L333">        }</span>

<span class="fc" id="L335">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.2.201409121644</span></div></body></html>